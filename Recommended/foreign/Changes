diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/R_systat.R Recommended/foreign/R/R_systat.R
22c22
<     if (!is.character(file)) stop("'file' must be character")
---
>     if (!is.character(file)) stop(gettextf("'%s' argument must be a character string", "file"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/Sread.R Recommended/foreign/R/Sread.R
66c66
< 		for (i in 1L:len) {
---
> 		for (i in seq_len(len)) {
110c110
< 		result <- call("stop", "Argument is missing")
---
> 		result <- call("stop", gettext("Argument is missing", domain = "R-foreign"))
114c114
< 	    return(paste("Unrecognized S mode", code, "not supported"))
---
> 	    return(gettextf("Unrecognized S mode %s is not supported", code, domain = "R-foreign"))
164,165c164
< 			     paste("Argument ", sQuote(name), " is missing",
<                                    sep=""))
---
> 			     gettextf("Argument %s is missing", sQuote(name), domain = "R-foreign"))
208,209c207
<             stop(gettextf("S mode %s (near byte offset %s) not supported",
<                           sQuote(code), seek(dump)), domain = NA)
---
>             stop(gettextf("S mode %s (near byte offset %s) not supported", sQuote(code), seek(dump)), domain = "R-foreign")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/arff.R Recommended/foreign/R/arff.R
32c32
<         stop("Argument 'file' must be a character string or connection.")
---
>         stop(gettextf("'%s' argument must be a character string or connection", "file"))
108c108
<         stop("Argument 'file' must be a character string or connection.")
---
>         stop(gettextf("'%s' argument must be a character string or connection", "file"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/dbf.R Recommended/foreign/R/dbf.R
28,30c28
<                 message(gettextf("Field name: %s changed to: %s",
<                                  sQuote(onames[i]), sQuote(inames[i])),
<                         domain = NA)
---
>                 message(gettextf("Field name: %s changed to: %s", sQuote(onames[i]), sQuote(inames[i])), domain = "R-foreign")
59,60c57
<                               "data frame contains columns of unsupported classes %s"),
< 
---
>                               "data frame contains columns of unsupported classes %s", domain = "R-foreign"),
100c97
<                 warning(gettextf("character column %d will be truncated to %d bytes", i, max_nchar), domain = NA)
---
>                 warning(gettextf("character column %d will be truncated to %d bytes", i, max_nchar), domain = "R-foreign")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/octave.R Recommended/foreign/R/octave.R
169,170c169
<         warning(gettextf("cannot handle unknown type %s", sQuote(type)),
<                 domain = NA)
---
>         warning(gettextf("cannot handle unknown type %s", sQuote(type)), domain = "R-foreign")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/spss.R Recommended/foreign/R/spss.R
97c97
<             message(gettextf("re-encoding from %s", cp), domain = NA)
---
>             message(gettextf("re-encoding from %s", cp), domain = "R-foreign")
163,164c163
<                     warning(gettextf("missingness type %s is not handled", tp),
<                             domain = NA)
---
>                     warning(gettextf("missingness type %s is not handled", tp), domain = "R-foreign")
202c201
<                 warning("Undeclared level(s) ", paste(addlevels, collapse = ", "), " added in variable: ", nm)
---
>                 warning(gettextf("Undeclared level(s) %s added in variable: %s", paste(addlevels, collapse = ", "), nm))
211,212c210
<               warning("Duplicated levels in factor ", nm, ": ", 
<                       paste(newlabels[dupnewlabels], collapse=", "))
---
>               warning(gettextf("Duplicated levels in factor %s: %s", nm, paste(newlabels[dupnewlabels], collapse=", ")))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/writeForeignSAS.R Recommended/foreign/R/writeForeignSAS.R
28c28
<       stop(gettextf("Cannot uniquely abbreviate the variable names to %d or fewer characters", nmax), domain = NA)
---
>       stop(gettextf("Cannot uniquely abbreviate the variable names to %d or fewer characters", nmax), domain = "R-foreign")
40,41c40
<     stop("Cannot uniquely abbreviate format names to conform to ",
<          " eight-character limit and not ending in a digit")
---
>     stop("Cannot uniquely abbreviate format names to conform to eight-character limit and not ending in a digit")
90c89
<             for(i in 1L:length(values)){
---
>             for(i in seq_len(length(values))){
135c134
<     for(v in 1L:ncol(df))
---
>     for(v in seq_len(ncol(df)))
141c140
<     for(v in 1L:ncol(df))
---
>     for(v in seq_len(ncol(df)))
147c146
<         for (f in 1L:length(fmtnames))
---
>         for (f in seq_len(length(fmtnames)))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/R_systat.c Recommended/foreign/src/R_systat.c
100a99
> #include "localization.h"
102,103c101
< static void swapb(void *result, int size)
< {
---
> static void swapb(void *result, int size) {
117,118c115
< SEXP readSystat(SEXP file)
< {
---
> SEXP readSystat(SEXP file) {
138c134,135
<     PROTECT(res = allocVector(VECSXP, getnv(use))); pc++;
---
> 	PROTECT(res = allocVector(VECSXP, getnv(use)));
> 	pc++;
146c143,144
<     PROTECT(resnames = allocVector(STRSXP, getnv(use))); pc++;
---
> 	PROTECT(resnames = allocVector(STRSXP, getnv(use)));
> 	pc++;
152c150,151
< 	PROTECT(comment = allocVector(STRSXP, 1)); pc++;
---
> 		PROTECT(comment = allocVector(STRSXP, 1));
> 		pc++;
164c163,164
< 		else REAL(VECTOR_ELT(res, i))[j] = x[j];
---
> 				else
> 					REAL(VECTOR_ELT(res, i))[j] = x[j];
175,176c175
< 		getsvar(use->h.fd, str,
< 			use->str_offset[use->ithstr[i]]);
---
> 				getsvar(use->h.fd, str, use->str_offset[use->ithstr[i]]);
192,193c191
< static void init_use(struct SysFilev3 *use)
< {
---
> static void init_use(struct SysFilev3 *use) {
227,228c224
< static void getuse(const char *fname, struct SysFilev3 *u)
< {
---
> static void getuse(const char *fname, struct SysFilev3 *u) {
243c238,239
<     j = 0; k = 0;
---
> 	j = 0;
> 	k = 0;
258c254,255
<     if(getoctal(&k, u->h.fd) != 1) error(_("getuse: File access error"));
---
> 	if (getoctal(&k, u->h.fd) != 1)
> 		error(_("getuse: File access error"));
286,288c283,287
< 		(u->h.nd % (FORTBUF / (u->h.ntype == 1 ? sizeof(float) : sizeof(double))))
< 		* (u->h.ntype == 1 ? sizeof(float) :
< 		   sizeof(double));
---
> 					(u->h.nd
> 							% (FORTBUF
> 									/ (u->h.ntype == 1 ?
> 											sizeof(float) : sizeof(double))))
> 							* (u->h.ntype == 1 ? sizeof(float) : sizeof(double));
334c333
< 	    sprintf(tmp, "Getuse: failure reading byte %d", end);
---
> 			sprintf(tmp, _("Getuse: failure reading byte %d"), end);
340c339,340
<     if (i >= 512) error(_("getuse: terminal null block"));
---
> 	if (i >= 512)
> 		error(_("getuse: terminal null block"));
346c346
< 	sprintf(tmp, "Getuse: last byte = %o octal", k);
---
> 		sprintf(tmp, _("Getuse: last byte = %o octal"), k);
362,364c362,363
< 	    u->local_offset[i] = (int) u->ithdb[i] *
< 		(u->h.ntype == 1 ? sizeof(float) :
< 		 sizeof(double))	/* the easy
---
> 			u->local_offset[i] = (int) u->ithdb[i]
> 					* (u->h.ntype == 1 ? sizeof(float) : sizeof(double)) /* the easy
368,369c367,371
< 		+ (u->ithdb[i] / (FORTBUF / (u->h.ntype == 1 ?
< 					     sizeof(float) : sizeof(double)))) * 2;
---
> 					+ (u->ithdb[i]
> 							/ (FORTBUF
> 									/ (u->h.ntype == 1 ?
> 											sizeof(float) : sizeof(double))))
> 							* 2;
373,374c375
< 	}
< 	else {			/* or a string */
---
> 		} else { /* or a string */
376,377c377,378
< 	    u->local_offset[i] = (int) (u->h.nd*(u->h.ntype == 1 ?
< 						  sizeof(float) : sizeof(double)))
---
> 			u->local_offset[i] = (int) (u->h.nd
> 					* (u->h.ntype == 1 ? sizeof(float) : sizeof(double)))
379,380c380,384
< 		+ (u->h.nd / (FORTBUF / (u->h.ntype == 1 ?
< 					 sizeof(float) : sizeof(double)))) * 2
---
> 					+ (u->h.nd
> 							/ (FORTBUF
> 									/ (u->h.ntype == 1 ?
> 											sizeof(float) : sizeof(double))))
> 							* 2
387,388c391,392
< 	    if(u->ithstr[i] >= 0
< 	       && u->str_offset[u->ithstr[i]] != 0) k++;
---
> 			if (u->ithstr[i] >= 0 && u->str_offset[u->ithstr[i]] != 0)
> 				k++;
405,406c408
< static void getlab(struct SysFilev3 *u)
< {
---
> static void getlab(struct SysFilev3 *u) {
422c424,425
< 	error(tmp1); }	/* read and throw away zeroth byte=0113 */
---
> 		error(tmp1);
> 	} /* read and throw away zeroth byte=0113 */
426c429,430
< 	error(tmp1); }
---
> 		error(tmp1);
> 	}
438c442,443
< 	error(tmp1);}
---
> 		error(tmp1);
> 	}
449c454,455
< 		error(tmp1); }
---
> 				error(tmp1);
> 			}
455,456c461,464
< 		    error(tmp1); }
< 		if (j == 0) isDollar = (o == '$');
---
> 					error(tmp1);
> 				}
> 				if (j == 0)
> 					isDollar = (o == '$');
460c468,469
< 		error(tmp1); }
---
> 				error(tmp1);
> 			}
478c487,488
< 	    error(tmp1); }
---
> 			error(tmp1);
> 		}
489c499,500
< 	    error(tmp1); }
---
> 			error(tmp1);
> 		}
503,505c514,517
< 	    sprintf(tmp1, _("getlab: byte lab[%d]0 = %o, nv=%d"),
< 		    j, o, u->h.nv);
< 	    error(tmp1); }
---
> 			sprintf(tmp1, _("getlab: byte lab[%d]0 = %o, nv=%d"), j, o,
> 					u->h.nv);
> 			error(tmp1);
> 		}
513c525,526
< 	if(label[8] == '$') u->h.nk++;
---
> 		if (label[8] == '$')
> 			u->h.nk++;
518c531,532
< 	} else u->h.nd++;	/* if the ninth char in label is '$',
---
> 		} else
> 			u->h.nd++; /* if the ninth char in label is '$',
523c537,538
< 	    if(label[i] != ' ') tmp[o++] = label[i];
---
> 			if (label[i] != ' ')
> 				tmp[o++] = label[i];
537c552,553
< 	    error(tmp1); }
---
> 			error(tmp1);
> 		}
550,552c565,567
< static void closeuse(struct SysFilev3 *use)
< {
<     if(use->h.flag != 0) fclose(use->h.fd);
---
> static void closeuse(struct SysFilev3 *use) {
> 	if (use->h.flag != 0)
> 		fclose(use->h.fd);
576,578c590,592
< static int getnv(struct SysFilev3 *use)
< {
<     if (isuse(use) == 0) return(-1);
---
> static int getnv(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
586,588c600,602
< static int getnd(struct SysFilev3 *use)
< {
<     if (isuse(use) == 0) return(-1);
---
> static int getnd(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
596,598c610,612
< static int getnk(struct SysFilev3 *use)
< {
<     if (isuse(use) == 0) return(-1);
---
> static int getnk(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
603,605c617,619
< static char *getvarnam(int i, struct SysFilev3 *use)
< {
<     if (isuse(use) == 0 || i >= use->h.nv) return(NULL);
---
> static char *getvarnam(int i, struct SysFilev3 *use) {
> 	if (isuse(use) == 0 || i >= use->h.nv)
> 		return (NULL);
611,614c624,628
< static int isdb(int i, struct SysFilev3 *use)
< {
<     if (use->ithdb[i] >= 0) return(0);
<     else return(-1);
---
> static int isdb(int i, struct SysFilev3 *use) {
> 	if (use->ithdb[i] >= 0)
> 		return (0);
> 	else
> 		return (-1);
619,620c632
< static int getmtype(struct SysFilev3 *use)
< {
---
> static int getmtype(struct SysFilev3 *use) {
625,626c637
< static int isuse(struct SysFilev3 *use)
< {
---
> static int isuse(struct SysFilev3 *use) {
634,636c645,647
< static int getnobs(struct SysFilev3 *use)
< {
<     if(isuse(use) == 0) return(-1);
---
> static int getnobs(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
647,648c657
< static int getdb(FILE *fd, short type, double *x)
< {
---
> static int getdb(FILE *fd, short type, double *x) {
653c662,663
< 	if(fread(&fx, sizeof(float), 1, fd) != 1) return(1);
---
> 		if (fread(&fx, sizeof(float), 1, fd) != 1)
> 			return (1);
657c667,668
< 	if(fread(&dx, sizeof(double), 1, fd) != 1) return(1);
---
> 		if (fread(&dx, sizeof(double), 1, fd) != 1)
> 			return (1);
686,689c697,700
<     }
<     else {
< 	if((fread(tmp_str, 1, (LABELSIZ - packet_bound), fd)) !=
< 	   (LABELSIZ - packet_bound)) error(_("file access error"));
---
> 	} else {
> 		if ((fread(tmp_str, 1, (LABELSIZ - packet_bound), fd))
> 				!= (LABELSIZ - packet_bound))
> 			error(_("file access error"));
695c706,707
< 	if((fseek(fd, 2L, SEEK_CUR)) != 0) error(_("file access error"));			/* hop over the packet boundary */
---
> 		if ((fseek(fd, 2L, SEEK_CUR)) != 0)
> 			error(_("file access error")); /* hop over the packet boundary */
697,698c709,710
< 	if((fread(tmp_str, 1, packet_bound, fd)) !=
< 	   packet_bound) error(_("file access error"));
---
> 		if ((fread(tmp_str, 1, packet_bound, fd)) != packet_bound)
> 			error(_("file access error"));
709,710c719
< static void getdbvar(int varno, double *db, struct SysFilev3 *use)
< {
---
> static void getdbvar(int varno, double *db, struct SysFilev3 *use) {
714c723,724
<     if (use->ithdb[varno] < 0) error(_("string variable"));
---
> 	if (use->ithdb[varno] < 0)
> 		error(_("string variable"));
716,717c726,728
<     if((j = fseek(use->h.fd, use->pos+use->local_offset[varno]+1L, SEEK_SET))
<        != 0) error(_("file access error"));
---
> 	if ((j = fseek(use->h.fd, use->pos + use->local_offset[varno] + 1L,
> 			SEEK_SET)) != 0)
> 		error(_("file access error"));
725c736,737
< 	if((j = getdb(use->h.fd, use->h.ntype, &x)) != 0) break;
---
> 		if ((j = getdb(use->h.fd, use->h.ntype, &x)) != 0)
> 			break;
737c749,750
<     if (j != 0) error(_("file access error"));
---
> 	if (j != 0)
> 		error(_("file access error"));
744,745c757
< static int getoctal(int *o, FILE *fp)
< {
---
> static int getoctal(int *o, FILE *fp) {
760,761c772
< static size_t getshort(short *sh, FILE *fp)
< {
---
> static size_t getshort(short *sh, FILE *fp) {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/Rdbfread.c Recommended/foreign/src/Rdbfread.c
30a31
> #include "localization.h"
56c57,58
<     if( hDBF == NULL ) error(_("unable to open DBF file"));
---
> 	if (hDBF == NULL)
> 		error(_("unable to open DBF file"));
61,62c63
<     if( DBFGetFieldCount(hDBF) == 0 )
<     {
---
> 	if (DBFGetFieldCount(hDBF) == 0) {
71c72,73
<     PROTECT(DataTypes = allocVector(STRSXP, nflds)); pc++;
---
> 	PROTECT(DataTypes = allocVector(STRSXP, nflds));
> 	pc++;
94c96,97
< 	buf[0] = hDBF->pachFieldType[i]; buf[1] = '\0';
---
> 		buf[0] = hDBF->pachFieldType[i];
> 		buf[1] = '\0';
98,101c101,105
<     PROTECT(df = allocVector(VECSXP, nRvar)); pc++;
<     PROTECT(varlabels = allocVector(STRSXP, nRvar)); pc++;
<     for(i = 0, nRvar = 0; i < nflds; i++)
<     {
---
> 	PROTECT(df = allocVector(VECSXP, nRvar));
> 	pc++;
> 	PROTECT(varlabels = allocVector(STRSXP, nRvar));
> 	pc++;
> 	for (i = 0, nRvar = 0; i < nflds; i++) {
123,124c127
<     for(iRecord = 0; iRecord < nrecs; iRecord++)
<     {
---
> 	for (iRecord = 0; iRecord < nrecs; iRecord++) {
143c146,147
< 			int ii, *it; double *r;
---
> 						int ii, *it;
> 						double *r;
206c210,211
<     PROTECT(tmp = mkString("data.frame")); pc++;
---
> 	PROTECT(tmp = mkString("data.frame"));
> 	pc++;
210c215,216
<     PROTECT(row_names = allocVector(STRSXP, nrecs)); pc++;
---
> 	PROTECT(row_names = allocVector(STRSXP, nrecs));
> 	pc++;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/Rdbfwrite.c Recommended/foreign/src/Rdbfwrite.c
32c32
< 
---
> #include "localization.h"
44,46c44
< 
< SEXP DoWritedbf(SEXP file, SEXP df, SEXP pr, SEXP sc, SEXP DataTypes)
< {
---
> SEXP DoWritedbf(SEXP file, SEXP df, SEXP pr, SEXP sc, SEXP DataTypes) {
53c51,52
<     if (hDBF == NULL) error(_("unable to open file"));
---
> 	if (hDBF == NULL)
> 		error(_("unable to open file"));
60,63c59,60
< 
< static DBFHandle
< Rdbfwrite(DBFHandle hDBF, SEXP df, SEXP pr, SEXP sc, SEXP DataTypes)
< {
---
> static DBFHandle Rdbfwrite(DBFHandle hDBF, SEXP df, SEXP pr, SEXP sc,
> 		SEXP DataTypes) {
84,85c81,82
< 		DBFAddField(hDBF, nameMangleOut(szTitle,11), FTInteger,
< 			    nWidth, 0);
---
> 				DBFAddField(hDBF, nameMangleOut(szTitle, 11), FTInteger, nWidth,
> 						0);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/SASxport.c Recommended/foreign/src/SASxport.c
31a32
> #include "localization.h"
63,64c63
< static double get_IBM_double(char* c, size_t len)
< {
---
> static double get_IBM_double(char* c, size_t len) {
98c97,98
<     if (c[1] == '\0' && c[0] != '\0') return R_NaReal;
---
> 	if (c[1] == '\0' && c[0] != '\0')
> 		return R_NaReal;
101c101,102
<     for (i = 1; i < 4; i++) buf[i] = c[i];
---
> 	for (i = 1; i < 4; i++)
> 		buf[i] = c[i];
104c105,106
<     for (i = 0; i < 4; i++) buf[i] = c[i + 4];
---
> 	for (i = 0; i < 4; i++)
> 		buf[i] = c[i + 4];
107,109c109,112
<     value = ((double) upper + ((double) lower)/Two32) *
< 	pow(16., (double) exponent);
<     if (negative) value = -value;
---
> 	value = ((double) upper + ((double) lower) / Two32)
> 			* pow(16., (double) exponent);
> 	if (negative)
> 		value = -value;
113,115c116,117
< static int
< get_nam_header(FILE *fp, struct SAS_XPORT_namestr *namestr, int length)
< {
---
> static int get_nam_header(FILE *fp, struct SAS_XPORT_namestr *namestr,
> 		int length) {
142,144c144
< static int
< get_lib_header(FILE *fp, struct SAS_XPORT_header *head)
< {
---
> static int get_lib_header(FILE *fp, struct SAS_XPORT_header *head) {
180,182c180
< static int
< get_mem_header(FILE *fp, struct SAS_XPORT_member *member)
< {
---
> static int get_mem_header(FILE *fp, struct SAS_XPORT_member *member) {
212,214c210
< static int
< init_xport_info(FILE *fp)
< {
---
> static int init_xport_info(FILE *fp) {
231,232c227,228
<     if(n != 80 || strncmp(MEM_HEADER, record, 75) != 0 ||
<        strncmp("  ", record+78, 2) != 0)
---
> 	if (n != 80 || strncmp(MEM_HEADER, record, 75) != 0
> 			|| strncmp("  ", record + 78, 2) != 0)
240,242c236
< static int
< init_mem_info(FILE *fp, char *name)
< {
---
> static int init_mem_info(FILE *fp, char *name) {
256,257c250,251
<     if(n != 80 || strncmp(NAM_HEADER, record, 54) != 0 ||
<        (strrchr(record+58, ' ') - record) != 79) {
---
> 	if (n != 80 || strncmp(NAM_HEADER, record, 54) != 0
> 			|| (strrchr(record + 58, ' ') - record) != 79) {
271c265,266
<     } else name[0] = '\0';
---
> 	} else
> 		name[0] = '\0';
278,282c273,275
< static int
< next_xport_info(FILE *fp, int namestr_length, int nvars, int *headpad,
< 		int *tailpad, int *length, int *ntype, int *nlng,
< 		int *nvar0, SEXP nname, SEXP nlabel, SEXP nform, int *npos)
< {
---
> static int next_xport_info(FILE *fp, int namestr_length, int nvars,
> 		int *headpad, int *tailpad, int *length, int *ntype, int *nlng,
> 		int *nvar0, SEXP nname, SEXP nlabel, SEXP nform, int *npos) {
384,385c377,378
< 	    if(n == 80 && strncmp(MEM_HEADER, record, 75) == 0 &&
< 	       strncmp("  ", record+78, 2) == 0) {
---
> 			if (n == 80 && strncmp(MEM_HEADER, record, 75) == 0
> 					&& strncmp("  ", record + 78, 2) == 0) {
391,392c384
< 	}
< 	else /* beware that the previous member can end on card
---
> 		} else /* beware that the previous member can end on card
394,396c386,387
< 	    if (restOfCard == 80 && n == 80 &&
< 		strncmp(MEM_HEADER, tmp, 75) == 0 &&
< 		strncmp("  ", tmp+78, 2) == 0) {
---
> 		if (restOfCard == 80 && n == 80 && strncmp(MEM_HEADER, tmp, 75) == 0
> 				&& strncmp("  ", tmp + 78, 2) == 0) {
416c407,408
< 	restOfCard = (restOfCard >= totwidth)?
---
> 		restOfCard =
> 				(restOfCard >= totwidth) ?
431,432c423
< static SEXP
< getListElement(SEXP list, char *str) {
---
> static SEXP getListElement(SEXP list, char *str) {
452,464c443,444
< const char *cVarInfoNames[] = {
<     "headpad",
<     "type",
<     "width",
<     "index",
<     "position",
<     "name",
<     "label",
<     "format",
<     "sexptype",
<     "tailpad",
<     "length"
< };
---
> const char *cVarInfoNames[] = { "headpad", "type", "width", "index", "position",
> 		"name", "label", "format", "sexptype", "tailpad", "length" };
493,495c473
< SEXP
< xport_info(SEXP xportFile)
< {
---
> SEXP xport_info(SEXP xportFile) {
522,523c500
<     while(!feof(fp))
<       {
---
> 	while (!feof(fp)) {
541,542c518
< 	namestrLength =
< 	    next_xport_info(fp, namestrLength, memLength,
---
> 		namestrLength = next_xport_info(fp, namestrLength, memLength,
548,551c524,525
< 			    INTEGER(XPORT_VAR_INDEX(varInfo)),
< 			    XPORT_VAR_NAME(varInfo),
< 			    XPORT_VAR_LABEL(varInfo),
< 			    XPORT_VAR_FORM(varInfo),
---
> 				INTEGER(XPORT_VAR_INDEX(varInfo)), XPORT_VAR_NAME(varInfo),
> 				XPORT_VAR_LABEL(varInfo), XPORT_VAR_FORM(varInfo),
557,558c531
< 			   (ntype[i] == REALSXP) ? char_numeric :
< 			   char_character);
---
> 					(ntype[i] == REALSXP) ? char_numeric : char_character);
587,589c560
< SEXP
< xport_read(SEXP xportFile, SEXP xportInfo)
< {
---
> SEXP xport_read(SEXP xportFile, SEXP xportInfo) {
647,648c618,619
< 		    REAL(VECTOR_ELT(data, k))[j] =
< 			get_IBM_double(tmpchar, dataWidth[k]);
---
> 					REAL(VECTOR_ELT(data, k))[j] = get_IBM_double(tmpchar,
> 							dataWidth[k]);
657,658c628
< 				   (c < tmpchar) ? R_BlankString :
< 				   mkChar(tmpchar));
---
> 							(c < tmpchar) ? R_BlankString : mkChar(tmpchar));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/avl.c Recommended/foreign/src/avl.c
28a29
> #include "localization.h"
42,43c43
< static void Free_fn(void *x, void *y)
< {
---
> static void Free_fn(void *x, void *y) {
52,53c52
< R_avl_create (MAYBE_POOL avl_comparison_func cmp, void *param)
< {
---
> R_avl_create(MAYBE_POOL avl_comparison_func cmp, void *param) {
56c55,56
<   if (!(cmp != NULL)) error("assert failed : cmp != NULL");
---
> 	if (!(cmp != NULL))
> 		error(_("assert failed : cmp != NULL"));
84,87c84,86
< void
< R_avl_destroy (avl_tree *tree, avl_node_func free_func)
< {
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> void R_avl_destroy(avl_tree *tree, avl_node_func free_func) {
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
102,103c101
<       for (;;)
< 	{
---
> 		for (;;) {
105,106c103
< 	  while (p != NULL)
< 	    {
---
> 			while (p != NULL) {
114,115c111
< 	  for (;;)
< 	    {
---
> 			for (;;) {
120,121c116
< 	      if (ab[ap] == 0)
< 		{
---
> 				if (ab[ap] == 0) {
145,147c140
< void
< R_avl_free (avl_tree *tree)
< {
---
> void R_avl_free(avl_tree *tree) {
152,155c145,147
< int
< R_avl_count (const avl_tree *tree)
< {
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> int R_avl_count(const avl_tree *tree) {
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
172,173c164
< new_node (void)
< {
---
> new_node(void) {
206c197
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL)) error(_("assert failed : tree != NULL"));
244c235
< 	      if (!(qp == qa)) error("assert failed : qp == qa");
---
> 				if (!(qp == qa)) error(_("assert failed : qp == qa"));
281c271
<   if (!(tree && walk_func)) error("assert failed : tree && walk_func");
---
> 	if (!(tree && walk_func)) error(_("assert failed : tree && walk_func"));
318c308
<   if (!(tree && trav)) error("assert failed : tree && trav");
---
> 	if (!(tree && trav)) error(_("assert failed : tree && trav"));
363,364c353
< avl_probe (avl_tree *tree, void *item)
< {
---
> avl_probe(avl_tree *tree, void *item) {
374c363,364
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
378,379c368
<   if (s == NULL)
<     {
---
> 	if (s == NULL) {
381c370,371
<       if (!(tree->count == 1)) error("assert failed : tree->count == 1");
---
> 		if (!(tree->count == 1))
> 			error(_("assert failed : tree->count == 1"));
389,390c379
<   for (;;)
<     {
---
> 	for (;;) {
395,396c384
<       if (diff < 0)
< 	{
---
> 		if (diff < 0) {
399,400c387
< 	  if (q == NULL)
< 	    {
---
> 			if (q == NULL) {
406,407c393
<       else if (diff > 0)
< 	{
---
> 		else if (diff > 0) {
410,411c396
< 	  if (q == NULL)
< 	    {
---
> 			if (q == NULL) {
415,416c400
< 	}
<       else
---
> 		} else
434,435c418
<   while (p != q)
<     {
---
> 	while (p != q) {
441,442c424
<   if (s->cache == 0)
<     {
---
> 	if (s->cache == 0) {
444,445c426
<       if (s->bal == 0)
< 	{
---
> 		if (s->bal == 0) {
448,450c429
< 	}
<       else if (s->bal == +1)
< 	{
---
> 		} else if (s->bal == +1) {
455,457c434,436
<       if (!(s->bal == -1)) error("assert failed : s->bal == -1");
<       if (r->bal == -1)
< 	{
---
> 		if (!(s->bal == -1))
> 			error(_("assert failed : s->bal == -1"));
> 		if (r->bal == -1) {
463,465c442
< 	}
<       else
< 	{
---
> 		} else {
467c444,445
< 	  if (!(r->bal == +1)) error("assert failed : r->bal == +1");
---
> 			if (!(r->bal == +1))
> 				error(_("assert failed : r->bal == +1"));
477,479c455,457
< 	  else
< 	    {
< 	      if (!(p->bal == +1)) error("assert failed : p->bal == +1");
---
> 			else {
> 				if (!(p->bal == +1))
> 					error(_("assert failed : p->bal == +1"));
484,486c462
<     }
<   else
<     {
---
> 	} else {
488,489c464
<       if (s->bal == 0)
< 	{
---
> 		if (s->bal == 0) {
492,494c467
< 	}
<       else if (s->bal == -1)
< 	{
---
> 		} else if (s->bal == -1) {
499,501c472,474
<       if (!(s->bal == +1)) error("assert failed : s->bal == +1");
<       if (r->bal == +1)
< 	{
---
> 		if (!(s->bal == +1))
> 			error(_("assert failed : s->bal == +1"));
> 		if (r->bal == +1) {
507,509c480
< 	}
<       else
< 	{
---
> 		} else {
511c482,483
< 	  if (!(r->bal == -1)) error("assert failed : r->bal == -1");
---
> 			if (!(r->bal == -1))
> 				error(_("assert failed : r->bal == -1"));
521,523c493,495
< 	  else
< 	    {
< 	      if (!(p->bal == -1)) error("assert failed : p->bal == -1");
---
> 			else {
> 				if (!(p->bal == -1))
> 					error(_("assert failed : p->bal == -1"));
541,542c513
< R_avl_find (const avl_tree *tree, const void *item)
< {
---
> R_avl_find(const avl_tree *tree, const void *item) {
545,547c516,518
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
<   for (p = tree->root.link[0]; p; )
<     {
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
> 	for (p = tree->root.link[0]; p;) {
583c554
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL)) error(_("assert failed : tree != NULL"));
672c643
<   if (!(k > 0)) error("assert failed : k > 0");
---
> 	if (!(k > 0)) error(_("assert failed : k > 0"));
692c663
< 	  if (!(s->bal == +1)) error("assert failed : s->bal == +1");
---
> 			if (!(s->bal == +1)) error(_("assert failed : s->bal == +1"));
695c666
< 	  if (!(r != NULL)) error("assert failed : r != NULL");
---
> 			if (!(r != NULL)) error(_("assert failed : r != NULL"));
716c687
< 	      if (!(r->bal == -1)) error("assert failed : r->bal == -1");
---
> 				if (!(r->bal == -1)) error(_("assert failed : r->bal == -1"));
728c699
< 		  if (!(p->bal == -1)) error("assert failed : p->bal == -1");
---
> 					if (!(p->bal == -1)) error(_("assert failed : p->bal == -1"));
737c708
< 	  if (!(a[k] == 1)) error("assert failed : a[k] == 1");
---
> 			if (!(a[k] == 1)) error(_("assert failed : a[k] == 1"));
751c722
< 	  if (!(s->bal == -1)) error("assert failed : s->bal == -1");
---
> 			if (!(s->bal == -1)) error(_("assert failed : s->bal == -1"));
785c756
< 		  if (!(p->bal == 1)) error("assert failed : p->bal == 1");
---
> 					if (!(p->bal == 1)) error(_("assert failed : p->bal == 1"));
801,802c772
< R_avl_insert (avl_tree *tree, void *item)
< {
---
> R_avl_insert(avl_tree *tree, void *item) {
805c775,776
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
816,817c787
< R_avl_replace (avl_tree *tree, void *item)
< {
---
> R_avl_replace(avl_tree *tree, void *item) {
820c790,791
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
825,826c796
<   else
<     {
---
> 	else {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/avl.h Recommended/foreign/src/avl.h
35,36c35
< typedef struct avl_node
<   {
---
> typedef struct avl_node {
42,43c41
<   }
< avl_node;
---
> } avl_node;
46,47c44
< typedef struct avl_traverser
<   {
---
> typedef struct avl_traverser {
52,53c49
<   }
< avl_traverser;
---
> } avl_traverser;
66,67c62
< typedef struct avl_tree
<   {
---
> typedef struct avl_tree {
75,76c70
<   }
< avl_tree;
---
> } avl_tree;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/dbfopen.c Recommended/foreign/src/dbfopen.c
196a197
> #include "localization.h"
276c277
< 	error("binary write error");
---
> 	error(_("binary write error"));
278c279
< 	!= psDBF->nFields) error("binary write error");
---
> 	!= psDBF->nFields) error(_("binary write error"));
289c290
< 	    error("binary write error");
---
> 	    error(_("binary write error"));
313c314
< 		    psDBF->fp ) != 1) error("binary write error");
---
> 		    psDBF->fp ) != 1) error(_("binary write error"));
334c335
< 	error("binary read error");
---
> 		error(_("binary read error"));
343c344
< 	error("binary write error");
---
> 		error(_("binary write error"));
719,720c720
<     if( psDBF->nCurrentRecord != hEntity )
<     {
---
> 	if (psDBF->nCurrentRecord != hEntity) {
725,727c725,726
< 	if( fseek( psDBF->fp, nRecordOffset, 0 ) != 0 )
< 	{
< 	    REprintf("fseek(%d) failed on DBF file", nRecordOffset);
---
> 		if (fseek(psDBF->fp, nRecordOffset, 0) != 0) {
> 			REprintf(_("fseek(%d) failed on DBF file"), nRecordOffset);
731,734c730,732
< 	if( fread( psDBF->pszCurrentRecord, psDBF->nRecordLength,
< 		   1, psDBF->fp ) != 1 )
< 	{
< 	    REprintf("fread(%d) failed on DBF file", psDBF->nRecordLength );
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1) {
> 			REprintf(_("fread(%d) failed on DBF file"), psDBF->nRecordLength);
746,747c744
<     if( psDBF->panFieldSize[iField]+1 > nStringFieldLen )
<     {
---
> 	if (psDBF->panFieldSize[iField] + 1 > nStringFieldLen) {
765,766c762
<     if( chReqType == 'N' )
<     {
---
> 	if (chReqType == 'N') {
942,943c938,939
< DBFGetFieldInfo( DBFHandle psDBF, int iField, char * pszFieldName,
< 		 int * pnWidth, int * pnDecimals )
---
> DBFGetFieldInfo(DBFHandle psDBF, int iField, char * pszFieldName, int * pnWidth,
> 		int * pnDecimals)
955,956c951
<     if( pszFieldName != NULL )
<     {
---
> 	if (pszFieldName != NULL) {
976,978c971
<     }
<     else
<     {
---
> 	} else {
1031,1032c1024,1026
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, 
< 		   psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
1199,1200c1193,1195
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 
< 		   1, psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
1346,1347c1341,1343
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 
< 		   1, psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
1391,1392c1387,1389
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 
< 		   1, psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/file-handle.c Recommended/foreign/src/file-handle.c
28a29
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/file-handle.h Recommended/foreign/src/file-handle.h
34,35c34
< enum
<   {
---
> enum {
42,43c41
< enum
<   {
---
> enum {
54,55c52
< struct fh_ext_class
<   {
---
> struct fh_ext_class {
64,65c61
< struct file_locator
<   {
---
> struct file_locator {
72,73c68
< struct file_handle
<   {
---
> struct file_handle {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/foreign.h Recommended/foreign/src/foreign.h
30a31
> #include <R_ext/Minmax.h>
33,41d33
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("foreign", String)
< #define gettext_noop(String) (String)
< #else
< #define _(String) (String)
< #define gettext_noop(String) (String)
< #endif
< 
68,76d59
< 
< #ifdef max
< # undef max
< #endif
< #ifdef min
< # undef min
< #endif
< #define max(a,b) ((a) >= (b) ? (a) : (b))
< #define min(a,b) ((a) <= (b) ? (a) : (b))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/format.c Recommended/foreign/src/format.c
24a25
> #include "localization.h"
29,30c30
< struct fmt_desc formats[FMT_NUMBER_OF_FORMATS + 1] =
< {
---
> struct fmt_desc formats[FMT_NUMBER_OF_FORMATS + 1] = {
32,33c32
<   {"",         -1, -1,  -1, -1,   -1, 0000, -1, -1},
< };
---
> 		{ "", -1, -1, -1, -1, -1, 0000, -1, -1 }, };
35,44c34,39
< const int translate_fmt[40] =
<   {
<     -1, FMT_A, FMT_AHEX, FMT_COMMA, FMT_DOLLAR, FMT_F, FMT_IB,
<     FMT_PIBHEX, FMT_P, FMT_PIB, FMT_PK, FMT_RB, FMT_RBHEX, -1,
<     -1, FMT_Z, FMT_N, FMT_E, -1, -1, FMT_DATE, FMT_TIME,
<     FMT_DATETIME, FMT_ADATE, FMT_JDATE, FMT_DTIME, FMT_WKDAY,
<     FMT_MONTH, FMT_MOYR, FMT_QYR, FMT_WKYR, FMT_PCT, FMT_DOT,
<     FMT_CCA, FMT_CCB, FMT_CCC, FMT_CCD, FMT_CCE, FMT_EDATE,
<     FMT_SDATE,
<   };
---
> const int translate_fmt[40] = { -1, FMT_A, FMT_AHEX, FMT_COMMA, FMT_DOLLAR,
> 		FMT_F, FMT_IB, FMT_PIBHEX, FMT_P, FMT_PIB, FMT_PK, FMT_RB, FMT_RBHEX,
> 		-1, -1, FMT_Z, FMT_N, FMT_E, -1, -1, FMT_DATE, FMT_TIME, FMT_DATETIME,
> 		FMT_ADATE, FMT_JDATE, FMT_DTIME, FMT_WKDAY, FMT_MONTH, FMT_MOYR,
> 		FMT_QYR, FMT_WKYR, FMT_PCT, FMT_DOT, FMT_CCA, FMT_CCB, FMT_CCC, FMT_CCD,
> 		FMT_CCE, FMT_EDATE, FMT_SDATE, };
85,86c80
< fmt_to_string (const struct fmt_spec *f)
< {
---
> fmt_to_string(const struct fmt_spec *f) {
96,98c90
< int
< check_input_specifier (const struct fmt_spec *spec)
< {
---
> int check_input_specifier(const struct fmt_spec *spec) {
106,107c98
<   if (f->cat & FCAT_OUTPUT_ONLY)
<     {
---
> 	if (f->cat & FCAT_OUTPUT_ONLY) {
111,113c102,105
<   if (spec->w < f->Imin_w || spec->w > f->Imax_w)
<     {
<       error(_("input format %s specifies a bad width %d.  Format %s requires a width between %d and %d"),
---
> 	if (spec->w < f->Imin_w || spec->w > f->Imax_w) {
> 		error(
> 				_(
> 						"input format %s specifies a bad width %d. Format %s requires a width between %d and %d"),
117,119c109,112
<   if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2)
<     {
<       error (_("input format %s specifies an odd width %d, but format %s requires an even width between %d and %d"),
---
> 	if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2) {
> 		error(
> 				_(
> 						"input format %s specifies an odd width %d, but format %s requires an even width between %d and %d"),
123,125c116,119
<   if (f->n_args > 1 && (spec->d < 0 || spec->d > 16))
<     {
<       error (_("Input format %s specifies a bad number of implied decimal places %d.  Input format %s allows up to 16 implied decimal places"),
---
> 	if (f->n_args > 1 && (spec->d < 0 || spec->d > 16)) {
> 		error(
> 				_(
> 						"Input format %s specifies a bad number of implied decimal places %d. Input format %s allows up to 16 implied decimal places"),
132,134c126
< int
< check_output_specifier (const struct fmt_spec *spec)
< {
---
> int check_output_specifier(const struct fmt_spec *spec) {
142,144c134,137
<   if (spec->w < f->Omin_w || spec->w > f->Omax_w)
<     {
<       error (_("output format %s specifies a bad width %d.  Format %s requires a width between %d and %d"),
---
> 	if (spec->w < f->Omin_w || spec->w > f->Omax_w) {
> 		error(
> 				_(
> 						"output format %s specifies a bad width %d. Format %s requires a width between %d and %d"),
151,153c144,147
<       && spec->w < f->Omin_w + 1 + spec->d)
<     {
<       error (_("output format %s requires minimum width %d to allow %d decimal places.  Try %s%d.%d instead of %s"),
---
> 			&& spec->w < f->Omin_w + 1 + spec->d) {
> 		error(
> 				_(
> 						"output format %s requires minimum width %d to allow %d decimal places. Try %s%d.%d instead of %s"),
158,160c152,155
<   if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2)
<     {
<       error (_("output format %s specifies an odd width %d, but output format %s requires an even width between %d and %d"),
---
> 	if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2) {
> 		error(
> 				_(
> 						"output format %s specifies an odd width %d, but output format %s requires an even width between %d and %d"),
164,166c159,162
<   if (f->n_args > 1 && (spec->d < 0 || spec->d > 16))
<     {
<       error (_("Output format %s specifies a bad number of implied decimal places %d.  Output format %s allows a number of implied decimal places between 1 and 16"),
---
> 	if (f->n_args > 1 && (spec->d < 0 || spec->d > 16)) {
> 		error(
> 				_(
> 						"Output format %s specifies a bad number of implied decimal places %d. Output format %s allows a number of implied decimal places between 1 and 16"),
175,177c171
< int
< check_string_specifier (const struct fmt_spec *f, int min_len)
< {
---
> int check_string_specifier(const struct fmt_spec *f, int min_len) {
179,181c173,176
<       || (f->type == FMT_AHEX && min_len * 2 > f->w))
<     {
<       error (_("cannot display a string variable of width %d with format specifier %s"),
---
> 			|| (f->type == FMT_AHEX && min_len * 2 > f->w)) {
> 		error(
> 				_(
> 						"cannot display a string variable of width %d with format specifier %s"),
188,190c183
< void
< convert_fmt_ItoO (const struct fmt_spec *input, struct fmt_spec *output)
< {
---
> void convert_fmt_ItoO(const struct fmt_spec *input, struct fmt_spec *output) {
197,198c190
<   switch (input->type)
<     {
---
> 	switch (input->type) {
217,218c209
<     case FMT_PIBHEX:
<       {
---
> 	case FMT_PIBHEX: {
221c212
< 	    error("convert_fmt_ItoO : assert failed");
---
> 			error(_("convert_fmt_ItoO: assert failed"));
243c234
<       error("convert_fmt_ItoO : invalid input->type : %d", input->type);
---
> 		error(_("convert_fmt_ItoO: invalid input->type: %d"), input->type);
277c268
<       error("convert_fmt_ItoO : invalid input->type : %d", input->type);
---
> 		error(_("convert_fmt_ItoO: invalid input->type: %d"), input->type);
Only in Recommended/foreign/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/minitab.c Recommended/foreign/src/minitab.c
30a31
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/pfm-read.c Recommended/foreign/src/pfm-read.c
35a36
> #include "localization.h"
101c102
<   "reading as a portable file",
---
>   N_("reading as a portable file"),
132,134c133
< static int
< fill_buf (struct file_handle *h)
< {
---
> static int fill_buf(struct file_handle *h) {
153,154c152
<   if (ext->trans)
<     {
---
> 	if (ext->trans) {
165,166c163
<  lossage:
<   return 0;
---
> 	lossage: return 0;
170,172c167
< static int
< read_char (struct file_handle *h)
< {
---
> static int read_char(struct file_handle *h) {
186,188c181
< static inline int
< skip_char (struct file_handle *h, int c)
< {
---
> static inline int skip_char(struct file_handle *h, int c) {
191,192c184
<   if (ext->cc == c)
<     {
---
> 	if (ext->cc == c) {
196,197c188
<  lossage:
<   return 0;
---
> 	lossage: return 0;
214,215c205
< pfm_read_dictionary (struct file_handle *h, struct pfm_read_info *inf)
< {
---
> pfm_read_dictionary(struct file_handle *h, struct pfm_read_info *inf) {
220,221c210
<   if (h->class == &pfm_r_class)
<     {
---
> 	if (h->class == &pfm_r_class) {
224,226c213
<     }
<   else if (h->class != NULL)
<     {
---
> 	} else if (h->class != NULL) {
240,241c227
<   if (ext->file == NULL)
<     {
---
> 	if (ext->file == NULL) {
243c229,231
<       error(_("an error occurred while opening \"%s\" for reading as a portable file: %s"),
---
> 		error(
> 				_(
> 						"an error occurred while opening \"%s\" for reading as a portable file: %s"),
301,303c289
< static double
< read_float (struct file_handle *h)
< {
---
> static double read_float(struct file_handle *h) {
315,317c301,303
<   if (pfm_match (137 /* * */))
<     {
<       advance ();	/* Probably a dot (.) but doesn't appear to matter. */
---
> 	if (pfm_match(137 /* * */)) {
> 		advance ();
> 		/* Probably a dot (.) but doesn't appear to matter. */
319,320c305
<     }
<   else if (pfm_match (141 /* - */))
---
> 	} else if (pfm_match(141 /* - */))
323,326c308,309
<   for (;;)
<     {
<       if (ext->cc >= 64 /* 0 */ && ext->cc <= 93 /* T */)
< 	{
---
> 	for (;;) {
> 		if (ext->cc >= 64 /* 0 */&& ext->cc <= 93 /* T */) {
346,347c329
< 	}
<       else if (!got_dot && ext->cc == 127 /* . */)
---
> 		} else if (!got_dot && ext->cc == 127 /* . */)
360,361c342
<   if (ext->cc == 130 /* + */ || ext->cc == 141 /* - */)
<     {
---
> 	if (ext->cc == 130 /* + */|| ext->cc == 141 /* - */) {
366,367c347
<       for (;;)
< 	{
---
> 		for (;;) {
392,393c372
<   else if (exponent > 0)
<     {
---
> 	else if (exponent > 0) {
404,405c383
<  overflow:
<   if (neg)
---
> 	overflow: if (neg)
410,411c388
<  lossage:
<   return NA_REAL;
---
> 	lossage: return NA_REAL;
415,417c392
< int
< read_int (struct file_handle *h)
< {
---
> int read_int(struct file_handle *h) {
426,427c401
<  lossage:
<   return NA_INTEGER;
---
> 	lossage: return NA_INTEGER;
434,435c408
< read_string (struct file_handle *h)
< {
---
> read_string(struct file_handle *h) {
458,459c431
<     for (i = 0; i < n; i++)
<       {
---
> 		for (i = 0; i < n; i++) {
468,469c440
<  lossage:
<   return NULL;
---
> 	lossage: return NULL;
473,475c444
< static int
< read_header (struct file_handle *h)
< {
---
> static int read_header(struct file_handle *h) {
491,492c460
<     for (i = 0; i < 256; i++)
<       {
---
> 		for (i = 0; i < 256; i++) {
583,584c551
<     for (i = 0; i < 6; i++)
<       {
---
> 		for (i = 0; i < 6; i++) {
590,591c557
<     if (inf)
<       {
---
> 		if (inf) {
634,637c600,601
< static int
< convert_format (struct file_handle *h, int fmt[3], struct fmt_spec *v,
< 		struct variable *vv)
< {
---
> static int convert_format(struct file_handle *h, int fmt[3], struct fmt_spec *v,
> 		struct variable *vv) {
650,655c614,630
<   if ((vv->type == ALPHA) ^ ((formats[v->type].cat & FCAT_STRING) != 0))
<     lose ((_("%s variable %s has %s format specifier %s"),
< 	   vv->type == ALPHA ? "String" : "Numeric",
< 	   vv->name,
< 	   formats[v->type].cat & FCAT_STRING ? "string" : "numeric",
< 	   formats[v->type].name));
---
> 	if ((vv->type == ALPHA) ^ ((formats[v->type].cat & FCAT_STRING) != 0)) {
> 		if (vv->type == ALPHA) {
> 			if (formats[v->type].cat & FCAT_STRING)
> 				lose(
> 						(_("String variable %s has string format specifier %s"), vv->name, formats[v->type].name));
> 			else
> 				lose(
> 						(_("String variable %s has numeric format specifier %s"), vv->name, formats[v->type].name));
> 		} else {
> 			if (formats[v->type].cat & FCAT_STRING)
> 				lose(
> 						(_("Numeric variable %s has string format specifier %s"), vv->name, formats[v->type].name));
> 			else
> 				lose(
> 						(_("Numeric variable %s has numeric format specifier %s"), vv->name, formats[v->type].name));
> 		}
> 	}
754,755c729,730
< 	lose ((_("position %d: Variable name has %u characters"),
< 	       i, strlen ((char *) name)));
---
> 			lose(
> 					(_("position %d: Variable name has %u characters"), i, strlen ((char *) name)));
758,762c733,738
< 	lose ((_("position %d: Variable name begins with invalid character"),
< 	       i));
<       if (name[0] >= 100 /* a */ && name[0] <= 125 /* z */)
< 	{
< 	  warning(_("position %d: Variable name begins with lowercase letter %c"),
---
> 			lose(
> 					(_("position %d: Variable name begins with invalid character"), i));
> 		if (name[0] >= 100 /* a */&& name[0] <= 125 /* z */) {
> 			warning(
> 					_(
> 							"position %d: Variable name begins with lowercase letter %c"),
772,774c748,751
< 	  if (c >= 100 /* a */ && c <= 125 /* z */)
< 	    {
< 	      warning(_("position %d: Variable name character %d is lowercase letter %c"),
---
> 			if (c >= 100 /* a */&& c <= 125 /* z */) {
> 				warning(
> 						_(
> 								"position %d: Variable name character %d is lowercase letter %c"),
777,779c754,755
< 	    }
< 	  else if ((c >= 64 /* 0 */ && c <= 99 /* Z */)
< 		   || c == 127 /* . */ || c == 152 /* @ */
---
> 			} else if ((c >= 64 /* 0 */&& c <= 99 /* Z */) || c == 127 /* . */
> 					|| c == 152 /* @ */
783,784c759,760
< 	    lose ((_("position %d: character `\\%03o' is not valid in a variable name"),
< 		   i, c));
---
> 				lose(
> 						(_("position %d: character `\\%03o' is not valid in a variable name"), i, c));
791,792c767,768
<       v = create_variable (ext->dict, (char *) name,
< 			   width ? ALPHA : NUMERIC, width);
---
> 		v = create_variable(ext->dict, (char *) name, width ? ALPHA : NUMERIC,
> 				width);
862,863c838,839
<     lose ((_("Weighting variable %s not present in dictionary"),
< 	   ext->dict->weight_var));
---
> 		lose(
> 				(_("Weighting variable %s not present in dictionary"), ext->dict->weight_var));
933,934c909,910
< 	lose ((_("Cannot assign value labels to %s and %s, which have different variable types or widths"),
< 	       v[0]->name, v[i]->name));
---
> 			lose(
> 					(_("Cannot assign value labels to %s and %s, which have different variable types or widths"), v[0]->name, v[i]->name));
979,980c955,956
< 	    lose ((_("Duplicate label for value %g for variable %s"),
< 		   vl->v.f, var->name));
---
> 				lose(
> 						(_("Duplicate label for value %g for variable %s"), vl->v.f, var->name));
982,983c958,959
< 	    lose ((_("Duplicate label for value `%.*s' for variable %s"),
< 		   var->width, vl->v.s, var->name));
---
> 				lose(
> 						(_("Duplicate label for value '%.*s' for variable %s"), var->width, vl->v.s, var->name));
1072,1073c1048
<  lossage:
<   Free (temp);
---
> 	lossage: Free(temp);
1078,1083c1053,1054
< static struct fh_ext_class pfm_r_class =
< {
<   5,
<   "reading as a portable file",
<   pfm_close,
< };
---
> static struct fh_ext_class pfm_r_class = { 5, N_("reading as a portable file"),
> 		pfm_close, };
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/pfm.h Recommended/foreign/src/pfm.h
30,33c30,31
< enum
<   {
<     PFM_COMM,
<     PFM_TAPE
---
> enum {
> 	PFM_COMM, PFM_TAPE
38,39c36
< struct pfm_read_info
<   {
---
> struct pfm_read_info {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/sfm-read.c Recommended/foreign/src/sfm-read.c
34a35
> #include "localization.h"
137c138
<   "reading as a system file",
---
> 	N_("reading as a system file"),
163c164
<   if (!(ext->opened == 0)) error("assert failed : ext->opened == 0");
---
>   if (!(ext->opened == 0)) error(_("assert failed : ext->opened == 0"));
222c223
<   if (!(v->ref_count >= 1)) error("assert failed : v->ref_count >= 1");
---
>   if (!(v->ref_count >= 1)) error(_("assert failed : v->ref_count >= 1"));
520c521
<   warning ("Read system-file dictionary successfully");
---
>   warning(_("Read system-file dictionary successfully"));
659,660c660
<     warning("%s: strange record info seen, size=%u, count=%u"
<       ", ignoring long variable names"
---
>     warning("%s: strange record info seen, size=%u, count=%u, ignoring long variable names"
687,688c687
<         warning("%s: long variable name mapping '%s' to '%s'"
<         "for variable which does not exist"
---
>         warning("for variable which does not exist: long variable name mapping '%s' to '%s'"
1425c1424
<   printf ("dictionary:\n");
---
>   printf (_("dictionary:\n"));
1484c1483
<           if (!(0)) warning("assert failed : 0");
---
>           if (!(0)) warning(_("assert failed : 0"));
1638c1637
<   if (!(dict->nval > 0)) error("assert failed : dict->nval > 0");
---
>   if (!(dict->nval > 0)) error(_("assert failed : dict->nval > 0"));
1694c1693
<   "reading as a system file",
---
>   N_("reading as a system file"),
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/sfm.h Recommended/foreign/src/sfm.h
35,36c35
< struct sfm_read_info
< {
---
> struct sfm_read_info {
56,57c55
< struct sfm_write_info
< {
---
> struct sfm_write_info {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/sfmP.h Recommended/foreign/src/sfmP.h
22,23c22
< struct sysfile_header
<   {
---
> struct sysfile_header {
39,40c38
< struct sysfile_variable
<   {
---
> struct sysfile_variable {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/shapefil.h Recommended/foreign/src/shapefil.h
197,198c197
< typedef struct
< {
---
> typedef struct {
257,258c255
< typedef struct
< {
---
> typedef struct {
305,307c302,303
<       SHPCreateObject( int nSHPType, int nShapeId,
< 		       int nParts, int * panPartStart, int * panPartType,
< 		       int nVertices, double * padfX, double * padfY,
---
> SHPCreateObject(int nSHPType, int nShapeId, int nParts, int * panPartStart,
> 		int * panPartType, int nVertices, double * padfX, double * padfY,
310,311c306,307
<       SHPCreateSimpleObject( int nSHPType, int nVertices,
< 			     double * padfX, double * padfY, double * padfZ );
---
> SHPCreateSimpleObject(int nSHPType, int nVertices, double * padfX,
> 		double * padfY, double * padfZ);
331,332c327
< typedef struct shape_tree_node
< {
---
> typedef struct shape_tree_node {
348,349c343
< typedef struct
< {
---
> typedef struct {
380,383c374,375
<       SHPTreeFindLikelyShapes( SHPTree * hTree,
< 			       double * padfBoundsMin,
< 			       double * padfBoundsMax,
< 			       int * );
---
> SHPTreeFindLikelyShapes(SHPTree * hTree, double * padfBoundsMin,
> 		double * padfBoundsMax, int *);
390,391c382
< typedef struct
< {
---
> typedef struct {
417,422c408
<   FTString,
<   FTInteger,
<   FTDouble,
<   FTLogical,
<   FTDate,
<   FTInvalid
---
> 	FTString, FTInteger, FTDouble, FTLogical, FTDate, FTInvalid
437,438c423,424
<       DBFAddField( DBFHandle hDBF, const char * pszFieldName,
< 		   DBFFieldType eType, int nWidth, int nDecimals );
---
> DBFAddField(DBFHandle hDBF, const char * pszFieldName, DBFFieldType eType,
> 		int nWidth, int nDecimals);
441,442c427,428
<       DBFGetFieldInfo( DBFHandle psDBF, int iField,
< 		       char * pszFieldName, int * pnWidth, int * pnDecimals );
---
> DBFGetFieldInfo(DBFHandle psDBF, int iField, char * pszFieldName, int * pnWidth,
> 		int * pnDecimals);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/spss.c Recommended/foreign/src/spss.c
29a30
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/stataread.c Recommended/foreign/src/stataread.c
46a47
> #include "localization.h"
460c461
< 			warning("invalid character string length -- truncating to 244 bytes");
---
> 			warning(_("invalid character string length -- truncating to 244 bytes"));
492c493
< 			warning("invalid character string length -- truncating to 244 bytes");
---
> 			warning(_("invalid character string length -- truncating to 244 bytes"));
803c804
< 		    warning("character strings of >244 bytes in column %d will be truncated", i+1);
---
> 		    warning(_("character strings of >244 bytes in column %d will be truncated"), i+1);
833c834
< 		    warning("character strings of >244 bytes in column %d will be truncated", i+1);
---
> 		    warning(_("character strings of >244 bytes in column %d will be truncated"), i+1);
970c971
< 		    error("empty string is not valid in Stata's documented format");
---
> 		    error(_("empty string is not valid in Stata's documented format"));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/var.h Recommended/foreign/src/var.h
52,53c52
< union value
<   {
---
> union value {
78,79c77
< struct value_label
<   {
---
> struct value_label {
88,89c86
< struct freq
<   {
---
> struct freq {
95,98c92,93
< enum
<   {
<     FRQM_GENERAL,
<     FRQM_INTEGER
---
> enum {
> 	FRQM_GENERAL, FRQM_INTEGER
102,103c97
< struct freq_tab
<   {
---
> struct freq_tab {
128,129c122
< struct freq_tab_set
<   {
---
> struct freq_tab_set {
143,144c136
< struct crosstab_proc
<   {
---
> struct crosstab_proc {
152,156c144,159
< enum
<   {
<     frq_mean = 0, frq_semean, frq_median, frq_mode, frq_stddev, frq_variance,
<     frq_kurt, frq_sekurt, frq_skew, frq_seskew, frq_range, frq_min, frq_max,
<     frq_sum, frq_n_stats
---
> enum {
> 	frq_mean = 0,
> 	frq_semean,
> 	frq_median,
> 	frq_mode,
> 	frq_stddev,
> 	frq_variance,
> 	frq_kurt,
> 	frq_sekurt,
> 	frq_skew,
> 	frq_seskew,
> 	frq_range,
> 	frq_min,
> 	frq_max,
> 	frq_sum,
> 	frq_n_stats
159,160c162
< struct frequencies_proc
<   {
---
> struct frequencies_proc {
173,174c175
< struct list_proc
<   {
---
> struct list_proc {
182,183c183
< enum
<   {
---
> enum {
187,189c187,199
<     dsc_mean = 0, dsc_semean, dsc_stddev, dsc_variance, dsc_kurt,
<     dsc_sekurt, dsc_skew, dsc_seskew, dsc_range, dsc_min,
<     dsc_max, dsc_sum, dsc_n_stats
---
> 	dsc_mean = 0,
> 	dsc_semean,
> 	dsc_stddev,
> 	dsc_variance,
> 	dsc_kurt,
> 	dsc_sekurt,
> 	dsc_skew,
> 	dsc_seskew,
> 	dsc_range,
> 	dsc_min,
> 	dsc_max,
> 	dsc_sum,
> 	dsc_n_stats
192,193c202
< struct descriptives_proc
<   {
---
> struct descriptives_proc {
211,212c220
< struct get_proc
<   {
---
> struct get_proc {
217,218c225
< enum
<   {
---
> enum {
224,225c231
< struct sort_cases_proc
<   {
---
> struct sort_cases_proc {
230,231c236
< struct modify_vars_proc
<   {
---
> struct modify_vars_proc {
238,239c243
< struct means_proc
<   {
---
> struct means_proc {
245,246c249
< enum
<   {
---
> enum {
257,258c260
< struct matrix_data_proc
<   {
---
> struct matrix_data_proc {
264,265c266
< struct match_files_proc
<   {
---
> struct match_files_proc {
273,274c274
< enum
<   {
---
> enum {
285,286c285
< enum
<   {
---
> enum {
303,304c302
< struct variable
<   {
---
> struct variable {
331,332c329
<     union
<       {
---
> 	union {
342,343c339
<       }
<     p;
---
> 	} p;
350,351c346
< struct ccase
<   {
---
> struct ccase {
358,359c353
< struct dictionary
<   {
---
> struct dictionary {
422,423c416
< enum
<   {
---
> enum {
469,470c462
< void replace_variable (struct variable *, const char *name,
< 		       int type, int width);
---
> void replace_variable(struct variable *, const char *name, int type, int width);
491,492c483
< struct trns_header
<   {
---
> struct trns_header {
520,521c511
< enum
<   {
---
> enum {
535,536c525,526
< int parse_variables (struct dictionary *dict, struct variable ***v,
< 		     int *nv, int pv_opts);
---
> int parse_variables(struct dictionary *dict, struct variable ***v, int *nv,
> 		int pv_opts);
