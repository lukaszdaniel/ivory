diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/bam.r Recommended/mgcv/R/bam.r
13c13
<  for (i in 1:n) sz[i] <- object.size(x[[i]])
---
>  for (i in seq_len(n)) sz[i] <- object.size(x[[i]])
38,39c38,39
<   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- 1:p
<   rank <- attr(R,"rank");ind <- 1:rank
---
>   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- seq_len(p)
>   rank <- attr(R,"rank");ind <- seq_len(rank)
71,72c71,72
<     fn <- qr.qty(qrx,yn)[1:p]
<     rp <- qrx$pivot;rp[rp] <- 1:p # reverse pivot
---
>     fn <- qr.qty(qrx,yn)[seq_len(p)]
>     rp <- qrx$pivot;rp[rp] <- seq_len(p) # reverse pivot
85c85
<   for (b in 1:arg$n.block) {
---
>   for (b in seq_len(arg$n.block)) {
134c134
<   for (i in 1:d) if (is.factor(dat[,i])) {  
---
>   for (i in seq_len(d)) if (is.factor(dat[,i])) {  
147c147
<     for (i in 1:d) if (!is.factor(dat[,i])) { ## round the metric variables
---
>     for (i in seq_len(d)) if (!is.factor(dat[,i])) { ## round the metric variables
171c171
<   ii <- sample(1:nrow(xu),nrow(xu),replace=FALSE) ## shuffling index
---
>   ii <- sample(seq_len(nrow(xu)),nrow(xu),replace=FALSE) ## shuffling index
237c237
<   if (length(gp$smooth.spec)>0) for (i in 1:length(gp$smooth.spec)) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
---
>   if (length(gp$smooth.spec)>0) for (i in seq_len(length(gp$smooth.spec))) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
240c240
<   k.start <- 1:(nk+1) ## record last column for each term
---
>   k.start <- seq_len(nk+1) ## record last column for each term
248c248
<   if (length(gp$smooth.spec)>0) for (i in 1:length(gp$smooth.spec)) {
---
>   if (length(gp$smooth.spec)>0) for (i in seq_len(length(gp$smooth.spec))) {
254c254
<     for (jj in 1:maxj) { ## loop through marginals
---
>     for (jj in seq_len(maxj)) { ## loop through marginals
314c314
<     for (i in 1:length(mf0)) {
---
>     for (i in seq_len(length(mf0))) {
328c328
<     mf <- mf[sample(1:nrow(mf),maxr,replace=TRUE),]
---
>     mf <- mf[sample(seq_len(nrow(mf)),maxr,replace=TRUE),]
351c351
<           ii0 <- if (ik>1) 1:(ik-1) else rep(0,0) ## earlier
---
>           ii0 <- if (ik>1) seq_len(ik-1) else rep(0,0) ## earlier
355c355
<           kk0 <- if (ik>1) 1:(k.start[ik]-1) else rep(0,0) ## earlier
---
>           kk0 <- if (ik>1) seq_len(k.start[ik]-1) else rep(0,0) ## earlier
376c376
<   for (j in 1:length(mf)) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
---
>   for (j in seq_len(length(mf))) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
390c390
<   ind <- sample(1:n,chunk.size)
---
>   ind <- sample(seq_len(n),chunk.size)
398c398
<   ind <- sample(1:n,n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
---
>   ind <- sample(seq_len(n),n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
401c401
<   for (j in 1:length(mf)) if (is.numeric(mf0[[j]])) {
---
>   for (j in seq_len(length(mf))) if (is.numeric(mf0[[j]])) {
403,404c403,404
<       j.min <- min((1:n)[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
<       j.max <- min((1:n)[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
---
>       j.min <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
>       j.max <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
461c461
<       ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>       ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
463c463
<       ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>       ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
523c523
<     if (length(Sl)>0) for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank
---
>     if (length(Sl)>0) for (b in seq_len(length(Sl))) rank <- rank + Sl[[b]]$rank
527c527
<     for (iter in 1L:control$maxit) { ## main fitting loop 
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop 
585c585
< 	      theta <- theta[1:family$n.theta]
---
> 	      theta <- theta[seq_len(family$n.theta)]
676c676
<         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[1:n.sp],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
---
>         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[seq_len(n.sp)],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
692c692
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
700c700
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
712c712
<   if (length(G$smooth)>1) for (i in 1:length(G$smooth)) Mp <- Mp + G$smooth[[i]]$null.space.dim
---
>   if (length(G$smooth)>1) for (i in seq_len(length(G$smooth))) Mp <- Mp + G$smooth[[i]]$null.space.dim
720c720
<   for (i in 1:ncol(prop$db)) prop$db[,i] <- ## d beta / d rho matrix
---
>   for (i in seq_len(ncol(prop$db))) prop$db[,i] <- ## d beta / d rho matrix
748c748
<   lsp <- if (n.sp>0) lsp[1:n.sp] else rep(0,0)
---
>   lsp <- if (n.sp>0) lsp[seq_len(n.sp)] else rep(0,0)
761c761
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
784,785c784,785
<   if (length(S)>0) for (i in 1:length(S)) {
<     ind <- off[i] - 1 + 1:ncol(S[[i]])
---
>   if (length(S)>0) for (i in seq_along(S)) {
>     ind <- off[i] - 1 + seq_len(ncol(S[[i]]))
868c868
<         warning("Too many cluster nodes to use all efficiently")
---
>         warning("too many cluster nodes to use all efficiently")
878c878
<       for (i in 1:n.threads) {
---
>       for (i in seq_len(n.threads)) {
885c885
<           stop <- (1:n.block)*chunk.size
---
>           stop <- seq_len(n.block)*chunk.size
915c915
<         stop <- (1:n.block)*chunk.size
---
>         stop <- seq_len(n.block)*chunk.size
934c934
<     for (iter in 1L:control$maxit) { ## main fitting loop
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop
942c942
<            for (b in 1:n.block) {
---
>            for (b in seq_len(n.block)) {
981c981
<           for (i in 1:length(arg)) {
---
>           for (i in seq_along(arg)) {
988c988
<           #for (i in 1:length(arg)) {
---
>           #for (i in seq_along(arg)) {
1015c1015
<             f <- qr.qty(qrx,f)[1:ncol(R)]
---
>             f <- qr.qty(qrx,f)[seq_len(ncol(R))]
1093c1093
< 	   theta <- theta[1:family$n.theta]
---
> 	   theta <- theta[seq_len(family$n.theta)]
1178c1178
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
1210c1210
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
1241c1241
<   for (i in 1:arg$n.block) {
---
>   for (i in seq_len(arg$n.block)) {
1247c1247
<        row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>        row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
1249c1249
<        stop <- c(1,1:(N-1)*2+1)
---
>        stop <- c(1,seq_len(N-1)*2+1)
1328c1328
<     for (i in 1:n.threads) { 
---
>     for (i in seq_len(n.threads)) { 
1394c1394
<          warning("Too many cluster nodes to use all efficiently")
---
>          warning("too many cluster nodes to use all efficiently")
1407c1407
<        for (i in 1:n.threads) { 
---
>        for (i in seq_len(n.threads)) { 
1454c1454
<        for (i in 1:n.block) {
---
>        for (i in seq_len(n.block)) {
1459c1459
<            row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>            row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
1461c1461
<            stop <- c(1,1:(N-1)*2+1) 
---
>            stop <- c(1,seq_len(N-1)*2+1) 
1501c1501
<        # for (i in 1:length(arg)) {
---
>        # for (i in seq_len(length(arg))) {
1522,1523c1522,1523
<          f <- qr.qty(qrx,f)[1:ncol(R)]
<          rp <- qrx$pivot;rp[rp] <- 1:ncol(R) # reverse pivot
---
>          f <- qr.qty(qrx,f)[seq_len(ncol(R))]
>          rp <- qrx$pivot;rp[rp] <- seq_len(ncol(R)) # reverse pivot
1533c1533
<        row <- c(1,rep(1:n,rep(2,n))[-c(1,2*n)])
---
>        row <- c(1,rep(seq_len(n),rep(2,n))[-c(1,2*n)])
1535c1535
<        stop <- c(1,1:(n-1)*2+1)
---
>        stop <- c(1,seq_len(n-1)*2+1)
1671c1671
<     warning("iterms reset to terms")
---
>     warning("type 'iterms' reset to type 'terms'")
1674c1674
<   if (!is.null(exclude)) warning("exclude ignored by discrete prediction at present")
---
>   if (!is.null(exclude)) warning("'exclude' argument ignored by discrete prediction at present")
1697,1698c1697,1698
<     object$coefficients <-  object$coefficients[1:object$nsdf]
<     object$Vp <- object$V[1:object$nsdf,1:object$nsdf]
---
>     object$coefficients <-  object$coefficients[seq_len(object$nsdf)]
>     object$Vp <- object$V[seq_len(object$nsdf),seq_len(object$nsdf)]
1722c1722
<      kd <- cbind(1:nrow(newdata),dk$k) ## add index for parametric part to index list
---
>      kd <- cbind(seq_len(nrow(newdata)),dk$k) ## add index for parametric part to index list
1736c1736
<   for (i in 1:length(object$smooth)) { ## work through the smooth list
---
>   for (i in seq_len(length(object$smooth))) { ## work through the smooth list
1739c1739
<       by.var <- dk$mf[[object$smooth[[i]]$by]][1:dk$nr[k]]
---
>       by.var <- dk$mf[[object$smooth[[i]]$by]][seq_len(dk$nr[k])]
1759c1759
<       for (j in 1:nmar) {
---
>       for (j in seq_len(nmar)) {
1791c1791
<     for (i in 1:length(object$smooth)) {
---
>     for (i in seq_len(length(object$smooth))) {
1863c1863
<   for (i in 1:ns) if (sm$margin[[i]]$bs.dim>=maxd) {
---
>   for (i in seq_len(ns)) if (sm$margin[[i]]$bs.dim>=maxd) {
1867c1867
<     ind <- 1:ns;ind[maxi] <- ns;ind[ns] <- maxi
---
>     ind <- seq_len(ns);ind[maxi] <- ns;ind[ns] <- maxi
1872c1872
<     for (i in 1:ns) sm$term <- c(sm$term,sm$margin[[i]]$term)
---
>     for (i in seq_len(ns)) sm$term <- c(sm$term,sm$margin[[i]]$term)
1885c1885
<   ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>   ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
1887c1887
<   ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>   ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
1930c1930
<                     "ML","P-REML","P-ML")) stop("un-supported smoothness selection method")
---
>                     "ML","P-REML","P-ML")) stop("unsupported smoothness selection method")
1960c1960
<       warning("no smooths, ignoring `discrete=TRUE'")
---
>       warning("no smooths, ignoring 'discrete=TRUE'")
1967c1967
<       for (i in 1:length(gp$smooth.spec)) { 
---
>       for (i in seq_len(length(gp$smooth.spec))) { 
1976c1976
<           for (j in 1:gp$smooth.spec[[i]]$dim) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
---
>           for (j in seq_len(gp$smooth.spec[[i]]$dim)) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
2006c2006
<     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("AR.start must be logical")
---
>     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("'AR.start' argument must be logical")
2080c2080
<         G$kd <- cbind(1:nrow(mf),dk$k) ## add index for parametric part to index list
---
>         G$kd <- cbind(seq_len(nrow(mf)),dk$k) ## add index for parametric part to index list
2094c2094
<       if (length(G$smooth)>0) for (i in 1:length(G$smooth)) {
---
>       if (length(G$smooth)>0) for (i in seq_len(length(G$smooth))) {
2099c2099
<           by.var <- dk$mf[[G$smooth[[i]]$by]][1:dk$nr[k]]
---
>           by.var <- dk$mf[[G$smooth[[i]]$by]][seq_len(dk$nr[k])]
2114c2114
< 	    rind <- 1:length(G$smooth[[i]]$term)
---
> 	    rind <- seq_along(G$smooth[[i]]$term)
2126,2127c2126,2127
<           for (j in 1:nmar) {
<             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[1:dk$nr[k],,drop=FALSE]
---
>           for (j in seq_len(nmar)) {
>             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[seq_len(dk$nr[k]),,drop=FALSE]
2149c2149
<           G$Xd[[k]] <- G$X[1:dk$nr[k],G$smooth[[i]]$first.para:G$smooth[[i]]$last.para,drop=FALSE]
---
>           G$Xd[[k]] <- G$X[seq_len(dk$nr[k]),G$smooth[[i]]$first.para:G$smooth[[i]]$last.para,drop=FALSE]
2193c2193
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2225c2225
<   if (control$trace) cat("Setup complete. Calling fit\n")
---
>   if (control$trace) cat(gettext("Setup complete. Calling fit", domain = "R-mgcv"), "\n", sep = "")
2241,2242c2241,2242
<       ind <- sample(1:nrow(mf),ceiling(nrow(mf)*samfrac))
<       if (length(ind)<2*ncol(G$X)) warning("samfrac too small - ignored") else {
---
>       ind <- sample(seq_len(nrow(mf)),ceiling(nrow(mf)*samfrac))
>       if (length(ind)<2*ncol(G$X)) warning("value of 'samfrac' argument is too small - ignored") else {
2264c2264
<   if (control$trace) cat("Fit complete. Finishing gam object.\n")
---
>   if (control$trace) cat(gettext("Fit complete. Finishing gam object.", domain = "R-mgcv"), "\n", sep = "")
2294c2294
<   if (G$nsdf>0) names(object$coefficients)[1:G$nsdf] <- colnamesX[1:G$nsdf]
---
>   if (G$nsdf>0) names(object$coefficients)[seq_len(G$nsdf)] <- colnamesX[seq_len(G$nsdf)]
2422c2422
<     row <- c(1,rep(1:m,rep(2,m))[-c(1,2*m)])
---
>     row <- c(1,rep(seq_len(m),rep(2,m))[-c(1,2*m)])
2424c2424
<     stop <- c(1,1:(m-1)*2+1)
---
>     stop <- c(1,seq_len(m-1)*2+1)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/coxph.r Recommended/mgcv/R/coxph.r
18c18
<         else stop(linktemp, " link not available for coxph family; available link is \"identity\" ")
---
>         else stop(gettextf("\"%s\" link not available for coxph family; available link is \"identity\"", linktemp))
84c84
< 	nt <- 0;for (i in 1:ns) nt <- nt + length(unique(y[strat==strat.lev[i]]))
---
> 	nt <- 0;for (i in seq_len(ns)) nt <- nt + length(unique(y[strat==strat.lev[i]]))
87c87
<         for (i in 1:ns) {
---
>         for (i in seq_len(ns)) {
107c107
< 	return(list(tr=tr,h=oo$h,q=oo$q,a=matrix(oo$A[1:(p*nt)],p,nt),nt=nt,r=r,km=oo$km))
---
> 	return(list(tr=tr,h=oo$h,q=oo$q,a=matrix(oo$A[seq_len(p*nt)],p,nt),nt=nt,r=r,km=oo$km))
111c111
<         for (i in 1:ns) { ## loop over strata
---
>         for (i in seq_len(ns)) { ## loop over strata
211c211
< #!! if (!is.null(offset)&&sum(offset!=0)) stop("cox.ph does not yet handle offsets")
---
> #!! if (!is.null(offset)&&sum(offset!=0)) stop("'cox.ph()' function does not yet handle offsets")
241,242c241,242
<       for (j in 1:ns) { ## loop over strata
<         ind <- if (ns==1) 1:length(y) else which(strat==strat.lev[j]) ## index for points in this strata
---
>       for (j in seq_len(ns)) { ## loop over strata
>         ind <- if (ns==1) seq_along(y) else which(strat==strat.lev[j]) ## index for points in this strata
263c263
<           ind <- 1:(p^2)
---
>           ind <- seq_len(p^2)
265c265
<           for (i in 1:M) { 
---
>           for (i in seq_len(M)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/efam.r Recommended/mgcv/R/efam.r
30c30
<       ind <- 1:length(g)
---
>       ind <- seq_along(g)
38c38
<       for (i in 1:nth) for (j in i:nth) {
---
>       for (i in seq_len(nth)) for (j in i:nth) {
164c164
<     } else stop(linktemp, " link not available for ordered categorical family; available links are \"identity\"")
---
>     } else stop(gettextf("\"%s\" link not available for ordered categorical family; available links are \"identity\"", linktemp))
204c204,205
<     paste("Ordered Categorical(",paste(round(family$getTheta(TRUE),2),collapse=","),")",sep="")
---
>     gettextf("Ordered Categorical(%s)", paste(round(family$getTheta(TRUE),2), collapse = ","), domain = "R-mgcv")
>     #paste("Ordered Categorical(",paste(round(family$getTheta(TRUE),2),collapse=","),")",sep="")
373c374
<       for (k in 1:(R-2)) { 
---
>       for (k in seq_len(R-2)) { 
423c424
<       for (j in 1:(R-2)) for (k in j:(R-2)) { 
---
>       for (j in seq_len(R-2)) for (k in j:(R-2)) { 
488c489
<       y <- c(1:R,y) ## make sure there is *something* in each class
---
>       y <- c(seq_len(R),y) ## make sure there is *something* in each class
535c536
<        for (i in 1:(R+1)) {
---
>        for (i in seq_len(R+1)) {
567c568
<       for (i in 1:R) {
---
>       for (i in seq_len(R)) {
596c597
<       for (i in 1:(R+1)) {
---
>       for (i in seq_len(R+1)) {
619c620
<     for (i in 1:R) {
---
>     for (i in seq_len(R)) {
655c656
<         else stop(linktemp, " link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"")
---
>         else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"", linktemp))
760c761,762
<       paste("Negative Binomial(",round(family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Negative Binomial(%s)", paste(round(family$getTheta(TRUE),3), sep = ", ", collapse = ""), domain = "R-mgcv")
>       #paste("Negative Binomial(",round(family$getTheta(TRUE),3),")",sep="")
810,811c812
<         else  stop(gettextf("link \"%s\" not available for Tweedie family.", 
<                 linktemp, collapse = ""), domain = NA)
---
>         else  stop(gettextf("link \"%s\" is not available for Tweedie family",  linktemp, collapse = ""), domain = "R-mgcv")
942c943
<       paste("Tweedie(p=",round(family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Tweedie(p=%s)", round(family$getTheta(TRUE),3), domain = "R-mgcv")
989c990
<         else stop(linktemp, " link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"")
---
>         else stop(gettextf("\"%s\" link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"", linktemp))
1136c1137
<       mu <- LS <- ii <- 1:length(y)
---
>       mu <- LS <- ii <- seq_len(length(y))
1194c1195
<       paste("Beta regression(",round(theta,3),")",sep="")
---
>       gettextf("Beta regression(%s)",round(theta,3), domain = "R-mgcv")
1278c1279
<         else stop(linktemp, " link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"")
---
>         else stop(gettextf("\"%s\" link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"", linktemp))
1452c1453
<       posr$family <- paste("Scaled t(",paste(th,collapse=","),")",sep="")
---
>       posr$family <- gettextf("Scaled t(%s)",paste(round(family$getTheta(TRUE),3), collapse=","), domain = "R-mgcv")
1562c1563
<   } else  stop(linktemp, " link not available for zero inflated; available link for `lambda' is only  \"loga\"")
---
>   } else  stop(gettextf("\"%s\" link not available for zero inflated; available link for `lambda' is only  \"loga\"", linktemp))
1688c1689
<       paste("Zero inflated Poisson(",paste(round(family$getTheta(TRUE),3),collapse=","),")",sep="")
---
>       gettextf("Zero inflated Poisson(%s)",paste(round(family$getTheta(TRUE),3),collapse=","), domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/fast-REML.r Recommended/mgcv/R/fast-REML.r
34,36c34,36
<     off <- unique(G$off[1:G$n.paraPen]) ## unique offset lists relating to paraPen
<     for (i in 1:length(off)) { ## loop over blocks
<       ind <- (1:G$n.paraPen)[G$off[1:G$n.paraPen]%in%off[i]] ## terms in same block
---
>     off <- unique(G$off[seq_len(G$n.paraPen)]) ## unique offset lists relating to paraPen
>     for (i in seq_along(off)) { ## loop over blocks
>       ind <- seq_len(G$n.paraPen)[G$off[seq_len(G$n.paraPen)]%in%off[i]] ## terms in same block
38c38
<         nr <- 0;for (k in 1:length(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
---
>         nr <- 0;for (k in seq_along(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
43c43
<         for (k in 1:length(ind)) { ## work through all penalties for this block
---
>         for (k in seq_along(ind)) { ## work through all penalties for this block
47c47
<             Sl[[b]]$S[[k]][1:nk,1:nk] <- G$S[[ind[k]]]
---
>             Sl[[b]]$S[[k]][seq_len(nk),seq_len(nk)] <- G$S[[ind[k]]]
67c67
<   if (length(G$smooth)) for (i in 1:length(G$smooth)) {
---
>   if (length(G$smooth)) for (i in seq_along(G$smooth)) {
98c98
<       for (j in 1:m) { ## get block range for each S[[j]]
---
>       for (j in seq_len(m)) { ## get block range for each S[[j]]
100c100
<         ir <- range((1:nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
---
>         ir <- range(seq_len(nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
104c104
<       for (j in 1:m) { ## test for overlap
---
>       for (j in seq_len(m)) { ## test for overlap
107c107
<           for (k in 1:m) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
112c112
<           for (k in 1:m) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
119c119
<         for (j in 1:m) {
---
>         for (j in seq_len(m)) {
151c151
<   for (b in 1:length(Sl)) { ## once more into the blocks, dear friends...
---
>   for (b in seq_along(Sl)) { ## once more into the blocks, dear friends...
168c168
<         ind[1:Sl[[b]]$rank] <- TRUE ## index penalized elements
---
>         ind[seq_len(Sl[[b]]$rank)] <- TRUE ## index penalized elements
199,200c199,200
<       ind <- 1:Sl[[b]]$rank
<       for (j in 1:length(Sl[[b]]$S)) { ## project penalties into range space of total penalty
---
>       ind <- seq_len(Sl[[b]]$rank)
>       for (j in seq_along(Sl[[b]]$S)) { ## project penalties into range space of total penalty
239c239
<   if (length(Sl)>0) for (b in 1:length(Sl)) {
---
>   if (length(Sl)>0) for (b in seq_along(Sl)) {
245c245
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_along(Sl[[b]]$S)) {
262c262
<   if (length(Sl)>0) for (b in 1:length(Sl)) {
---
>   if (length(Sl)>0) for (b in seq_along(Sl)) {
268c268
<   if (length(Sl)>0) for (b in 1:length(Sl)) {
---
>   if (length(Sl)>0) for (b in seq_along(Sl)) {
271c271
<       a[kk + 1:length(ind)] <- beta[ind] * exp(rho[k]/2)
---
>       a[kk + seq_along(ind)] <- beta[ind] * exp(rho[k]/2)
275,276c275,276
<       for (j in 1:length(Sl[[b]]$S)) {
<         a[kk + 1:length(ind)] <- exp(rho[k]/2) * (beta[ind] %*% Sl[[b]]$rS[[j]])
---
>       for (j in seq_along(Sl[[b]]$S)) {
>         a[kk + seq_along(ind)] <- exp(rho[k]/2) * (beta[ind] %*% Sl[[b]]$rS[[j]])
297c297
<         for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>         for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
310c310
<          for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>          for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
326c326
<       for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>       for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
332c332
<   } else for (b in 1:length(Sl)) if (Sl[[b]]$repara) { ## model matrix re-para
---
>   } else for (b in seq_along(Sl)) if (Sl[[b]]$repara) { ## model matrix re-para
379c379
<     rp <- piv;rp[rp] <- 1:p ## reverse pivot
---
>     rp <- piv;rp[rp] <- seq_len(p) ## reverse pivot
383,384c383,384
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
388c388
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
394c394
<       for (j in 1:i) {
---
>       for (j in seq_len(i)) {
421c421
<   if (length(Sl)>0) for (b in 1:length(Sl)) { ## work through blocks
---
>   if (length(Sl)>0) for (b in seq_along(Sl)) { ## work through blocks
434c434
<           D <- Sl[[b]]$Di[1:Sl[[b]]$rank,]
---
>           D <- Sl[[b]]$Di[seq_len(Sl[[b]]$rank),]
465c465
<         for (i in 1:m) {
---
>         for (i in seq_len(m)) {
506c506
<   if (length(Sl)>0) for (b in 1:length(Sl)) {
---
>   if (length(Sl)>0) for (b in seq_along(Sl)) {
514c514
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_along(Sl[[b]]$S)) {
530c530
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
536c536
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_along(Sl[[b]]$S)) {
554c554
<       for (i in 1:nr) if (rp[[i]]$repara) {
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) {
561c561
<      for (i in 1:nr) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
---
>      for (i in seq_len(nr)) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
565c565
<       for (i in 1:nr) if (rp[[i]]$repara) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
567c567
<       for (i in 1:nr) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
583c583
<     for (b in 1:nb) { ## block loop
---
>     for (b in seq_len(nb)) { ## block loop
603,604c603,604
<     for (b in 1:nb) { ## block loop
<       for (i in 1:length(Sl[[b]]$S)) { ## S loop within blocks
---
>     for (b in seq_len(nb)) { ## block loop
>       for (i in seq_along(Sl[[b]]$S)) { ## S loop within blocks
671c671
<   if (nb>0) for (b in 1:nb) { ## block loop
---
>   if (nb>0) for (b in seq_len(nb)) { ## block loop
701c701
<       for (i in 1:length(Sl[[b]]$S)) { ## work through S terms
---
>       for (i in seq_along(Sl[[b]]$S)) { ## work through S terms
743c743
<   for (i in 1:nd) { 
---
>   for (i in seq_len(nd)) { 
770c770
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
780c780
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
874,875c874,875
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
906c906
<     reml2 <- rbind(cbind(reml2,d[1:n]),d) 
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d) 
954c954
<   rp <- qrx$pivot;rp[rp] <- 1:np ## reverse pivot vector
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(np) ## reverse pivot vector
958,959c958,959
<   beta <- backsolve(R,Qty0)[1:np]
<   rss.bSb <- sum(Qty0[-(1:np)]^2) + rss.extra
---
>   beta <- backsolve(R,Qty0)[seq_len(np)]
>   rss.bSb <- sum(Qty0[-seq_len(np)]^2) + rss.extra
984c984
<     reml2 <- rbind(cbind(reml2,d[1:n]),d)
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d)
1011c1011
<     rp[rp] <- 1:np
---
>     rp[rp] <- seq_len(np)
1014,1015c1014,1015
<     rss.extra <- rss.extra + sum(y[-(1:np)]^2)
<     y <- y[1:np]
---
>     rss.extra <- rss.extra + sum(y[-seq_len(np)]^2)
>     y <- y[seq_len(np)]
1055c1055
<   for (iter in 1:200) { ## the Newton loop
---
>   for (iter in seq_len(200)) { ## the Newton loop
1079c1079
<     trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt,gamma=gamma)
---
>     trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt,gamma=gamma)
1093c1093
<       trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt,gamma=gamma)
---
>       trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt,gamma=gamma)
1122,1124c1122,1124
<   if (step.failed) best$conv <- "step failed" else
<   if (iter==200) best$conv <- "no convergence in 200 iterations" else
<   best$conv <- "full convergence"
---
>   if (step.failed) best$conv <- gettext("step failed", domain = "R-mgcv") else
>   if (iter==200) best$conv <- gettext("no convergence in 200 iterations", domain = "R-mgcv") else
>   best$conv <- gettext("full convergence", domain = "R-mgcv")
1146,1147c1146,1147
<   drop <- qrx$pivot[-(1:rank)] ## index of un-identifiable coefs
<   undrop <- 1:ncol(X) 
---
>   drop <- qrx$pivot[-seq_len(rank)] ## index of un-identifiable coefs
>   undrop <- seq_len(ncol(X))
1170c1170
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
1190c1190
<       for (i in 1:length(Sl[[b]]$S)) {
---
>       for (i in seq_along(Sl[[b]]$S)) {
1200c1200
<     for (i in 1:length(Sl)) {
---
>     for (i in seq_along(Sl)) {
1223c1223
<   for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
---
>   for (b in seq_along(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
1243c1243
<     for (i in 1:ncol(d1b)) d1b[,i] <- 
---
>     for (i in seq_len(ncol(d1b))) d1b[,i] <- 
1266c1266
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamlss.r Recommended/mgcv/R/gamlss.r
37c37
<   for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>   for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
51c51
<   for (j in 1:K) for (k in j:K) for (l in k:K) {
---
>   for (j in seq_len(K)) for (k in j:K) for (l in k:K) {
59c59
<   for (k in 1:K) for (l in k:K) {
---
>   for (k in seq_len(K)) for (l in k:K) {
66c66
<   for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>   for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
72c72
<   for (j in 1:K) for (k in j:K) for (l in k:K) {
---
>   for (j in seq_len(K)) for (k in j:K) for (l in k:K) {
78c78
<   for (k in 1:K) for (l in k:K) {
---
>   for (k in seq_len(K)) for (l in k:K) {
98c98
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
106c106
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
123c123
<   if (deriv>0) for (i in 1:K) for (j in i:K) for (l in j:K) {
---
>   if (deriv>0) for (i in seq_len(K)) for (j in i:K) for (l in j:K) {
150c150
<   if (deriv>2) for (i in 1:K) for (j in i:K) for (l in j:K) for (m in l:K) {
---
>   if (deriv>2) for (i in seq_len(K)) for (j in i:K) for (l in j:K) for (m in l:K) {
218c218
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
224c224
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
236,237c236,237
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
245,248c245,248
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
259c259
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
261,263c261,263
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
278,279c278,279
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
288c288
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
293,294c293,294
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
300c300
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
302,304c302,304
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
306,307c306,307
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
314c314
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
317,318c317,318
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
356c356
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
362c362
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
376,377c376,377
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
385,388c385,388
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
399c399
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
401,403c401,403
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
420,421c420,421
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
430c430
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
435,436c435,436
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
442c442
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
444,446c444,446
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
448,449c448,449
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
456c456
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
459,460c459,460
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
479c479
<   lpi <- list(); for (i in 1:nlp) lpi[[i]] <- i
---
>   lpi <- list(); for (i in seq_len(nlp)) lpi[[i]] <- i
505c505
<   if (!is.null(offset)) for (i in 1:nlp) if (!is.null(offset[[i]])) eta[,i] <- eta[,i] + offset[[i]] 
---
>   if (!is.null(offset)) for (i in seq_len(nlp)) if (!is.null(offset[[i]])) eta[,i] <- eta[,i] + offset[[i]] 
507c507
<   for (i in 1:nlp) mu[,i] <- family$linfo[[i]]$linkinv(eta[,i])
---
>   for (i in seq_len(nlp)) mu[,i] <- family$linfo[[i]]$linkinv(eta[,i])
525c525
<   if (length(link)!=2) stop("gaulss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "gaulss()"))
529c529
<   stop(link[[1]]," link not available for mu parameter of gaulss")
---
>   stop(gettextf("\"%s\" link not available for mu parameter of gaulss", link[[1]]))
551c551
<   } else stop(link[[2]]," link not available for precision parameter of gaulss")
---
>   } else stop(gettextf("\"%s\" link not available for precision parameter of gaulss", link[[2]]))
722c722
<   for (i in 1:K) {
---
>   for (i in seq_len(K)) {
745c745
<       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[1:n + object$y*n]))) 
---
>       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[seq_len(n) + object$y*n]))) 
760c760
<         lpi <- list(1:ncol(X))
---
>         lpi <- list(seq_len(ncol(X)))
768c768
<       for (i in 1:K) { 
---
>       for (i in seq_len(K)) { 
789c789
<       for (j in 1:(K+1)) {
---
>       for (j in seq_len(K+1)) {
798c798
<         for (i in 1:K) if (i<K) for (k in (i+1):K) {
---
>         for (i in seq_len(K)) if (i<K) for (k in (i+1):K) {
842,843c842,843
<       for (i in 1:K) if (is.null(offset[[i]])) offset[[i]] <- 0
<       for (i in 1:K) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]] + offset[[i]]
---
>       for (i in seq_len(K)) if (is.null(offset[[i]])) offset[[i]] <- 0
>       for (i in seq_len(K)) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]] + offset[[i]]
853c853
<     l0 <- eta[1:n+y*n] - alpha ## log likelihood
---
>     l0 <- eta[seq_len(n)+y*n] - alpha ## log likelihood
859c859
<       for (i in 1:K) l1[,i] <- ee[,i]/beta ## alpha1
---
>       for (i in seq_len(K)) l1[,i] <- ee[,i]/beta ## alpha1
865c865
<       for (i in 1:K) for (j in i:K) {
---
>       for (i in seq_len(K)) for (j in i:K) {
871c871
<       for (i in 1:K) l1[,i] <- as.numeric(y==i) - l1[,i] 
---
>       for (i in seq_len(K)) l1[,i] <- as.numeric(y==i) - l1[,i] 
881c881
<       for (i in 1:K) for (j in i:K) for (k in j:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) {
897c897
<       for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
945c945
<         for (k in 1:length(jj)) { ## loop over the linear predictors      
---
>         for (k in seq_len(length(jj))) { ## loop over the linear predictors      
988c988
<   Qy <- qr.qty(qrx,y)[1:ncol(R)]  
---
>   Qy <- qr.qty(qrx,y)[seq_len(ncol(R))]  
993c993
<   edf <- sum(qr.Q(qrr)[1:r,]^2) 
---
>   edf <- sum(qr.Q(qrr)[seq_len(r),]^2) 
997c997
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
1002c1002
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
1201c1201
<   if (length(link)!=2) stop("ziplss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "ziplss()"))
1207c1207
<     stop(link[[i]]," link not available for ",param.names[i]," parameter of ziplss")
---
>     stop(gettextf("\"%s\" link not available for parameter of ziplss %s", param.names[i], link[[i]]))
1442c1442
<         p <- drop(x1[1:nobs,,drop=FALSE] %*% startji) ## probability of presence
---
>         p <- drop(x1[seq_len(nobs),,drop=FALSE] %*% startji) ## probability of presence
1490c1490
<     stop(link[[i]]," link not available for mu parameter of gaulss")
---
>     stop(gettextf("'%s' link not available for mu parameter of gaulss", link[[i]]))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamm.r Recommended/mgcv/R/gamm.r
134c134
<   if (sum(is.na(value))>0) warning("NA's in pdTens factor")
---
>   if (sum(is.na(value))>0) warning("NA values in factor of class \"pdTens\"")
157c157
<   if (sum(is.na(value))>0) warning("NA's in pdTens matrix")
---
>   if (sum(is.na(value))>0) warning("NA values in matrix of class \"pdTens\"")
173c173
<     names(val) <- paste("sp.",1:length(val), sep ="")
---
>     names(val) <- paste("sp.", seq_len(length(val)), sep ="")
179c179
<   function(object, structName = "Tensor product smooth term", ...)
---
>   function(object, structName = gettext("Tensor product smooth term", domain = "R-mgcv"), ...)
219c219
<     nm <- paste("V", 1:len, sep = "")
---
>     nm <- paste("V", seq_len(len), sep = "")
246,247c246
<     stop(paste("An object of length", length(val),
< 	       "does not match the required parameter size"))
---
>     stop(gettextf("An object of length %d does not match the required parameter size", length(val)))
250,251c249
<     stop(paste("Must give names when initializing pdIdnot from parameter.",
< 	       "without a formula"))
---
>     stop("Must give names when initializing pdIdnot from parameter without a formula")
273c271
<     stop(paste("Cannot extract the matrix with uninitialized dimensions"))
---
>     stop("Cannot extract the matrix with uninitialized dimensions")
331c329
<   function(object, structName = "Multiple of an Identity", ...)
---
>   function(object, structName = gettext("Multiple of an Identity", domain = "R-mgcv"), ...)
360c358
<   ind <- 1:colx 
---
>   ind <- seq_len(colx )
372c370
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
396c394
<       for (j in 1:n.lev) { ## assemble full sparse model matrix
---
>       for (j in seq_len(n.lev)) { ## assemble full sparse model matrix
407c405
<     ind <- 1:length(rind)
---
>     ind <- seq_along(rind)
445c443
<   ind <- 1:ncol(object$X)
---
>   ind <- seq_len(ncol(object$X))
448c446
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_along(object$S)) { ## work through penalties
478c476
<        rind=1:n.para,rinc=rep(n.para,n.para),pen.ind=pen.ind)
---
>        rind=seq_len(n.para),rinc=rep(n.para,n.para),pen.ind=pen.ind)
509c507
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
525c523
<     attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE]
---
>     attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE]
527c525
<     random <- list(X[,1:p.rank,drop=FALSE]) 
---
>     random <- list(X[, seq_len(p.rank), drop = FALSE]) 
531c529
<   rind <- 1:p.rank
---
>   rind <- seq_len(p.rank)
586,588c584,585
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
<   if (sum(D<=0)) stop(
<   "Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
>   if (sum(D<=0)) stop("Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
595,596c592,593
<   for (l in 1:length(object$S)) {   # transform penalty explicitly
<     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[1:p.rank,1:p.rank]
---
>   for (l in seq_len(length(object$S))) {   # transform penalty explicitly
>     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[seq_len(p.rank), seq_len(p.rank)]
609,610c606,607
<   attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE] ## random effect model matrix
<   rind <- 1:p.rank
---
>   attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE] ## random effect model matrix
>   rind <- seq_len(p.rank)
622c619
<                       data=stop("No data supplied to gamm.setup"),knots=NULL,
---
>                       data=stop(gettextf("No data supplied to '%s' function", "gamm.setup()")),knots=NULL,
646c643
<   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of `id' or adaptive smooths)")
---
>   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of 'id' or adaptive smooths)")
655c652
<   if (G$nsdf>0) ind <- 1:G$nsdf else ind <- rep(0,0)  
---
>   if (G$nsdf>0) ind <- seq_len(G$nsdf) else ind <- rep(0,0)  
664c661
<     pord <- 1:G$m
---
>     pord <- seq_len(G$m)
668c665
<     for (i in 1:G$m) if (is.null(G$smooth[[i]]$fac)) { 
---
>     for (i in seq_len(G$m)) if (is.null(G$smooth[[i]]$fac)) { 
675c672
<       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions not allowed for nested smooths")
---
>       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions are not allowed for nested smooths")
677c674
<     if (k < G$m) pord[(k+1):G$m] <- (1:G$m)[!done] 
---
>     if (k < G$m) pord[(k+1):G$m] <- seq_len(G$m)[!done] 
681c678
<   if (G$m) for (i in 1:G$m) { ## work through the smooths
---
>   if (G$m) for (i in seq_len(G$m)) { ## work through the smooths
698c695
<       for (k in 1:length(rasm$rand)) {
---
>       for (k in seq_len(length(rasm$rand))) {
720c717
<       for (j in 1:ncol(rasm$Xf)) {
---
>       for (j in seq_len(ncol(rasm$Xf))) {
803c800
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
848c845
<     rCind <- 1:n; rCind[Cind] <- 1:n
---
>     rCind <- seq_len(n); rCind[Cind] <- seq_len(n)
854c851
<     for (i in 1:n.cg) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
---
>     for (i in seq_len(n.cg)) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
857c854
<   } else {n.cg <- 1;Cind<-1:n}
---
>   } else {n.cg <- 1;Cind<-seq_len(n)}
880c877
<       for (i in 1:n.cg) { 
---
>       for (i in seq_len(n.cg)) { 
882c879
<         ind[[i]] <- 1:size.cg[i]
---
>         ind[[i]] <- seq_len(size.cg[i])
890,891c887,888
<       ii <- 1:n
<       for (i in 1:n.g) # work through innermost groups
---
>       ii <- seq_len(n)
>       for (i in seq_len(n.g)) # work through innermost groups
895c892
<         k <- (1:n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
---
>         k <- seq_len(n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
908c905
<       for (k in 1:n.cg) { # pasting correlations into right place in each matrix
---
>       for (k in seq_len(n.cg)) { # pasting correlations into right place in each matrix
915c912
<   { for (i in 1:n.cg)
---
>   { for (i in seq_len(n.cg))
938c935
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
954c951
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
956c953
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
975c972
<       for (i in 1:n.cg) {
---
>       for (i in seq_len(n.cg)) {
982c979
<         for (i in 1:n.cg) V[[i]] <- V[[i]]+Vz[[i]] 
---
>         for (i in seq_len(n.cg)) V[[i]] <- V[[i]]+Vz[[i]] 
985c982
<         for (i in 1:n.cg) {
---
>         for (i in seq_len(n.cg)) {
1004c1001
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
1033,1034c1030,1031
<       ind<-ii<-1:n
<       for (i in 1:n.g) 
---
>       ind<-ii<-seq_len(n)
>       for (i in seq_len(n.g)) 
1056c1053
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
1072c1069
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
1074c1071
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
1094c1091
<     for (i in 1:length(V$V))
---
>     for (i in seq_len(length(V$V)))
1152,1153c1149
<   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,",
<                         "weights =",wts.name,",...)")))
---
>   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,", "weights =",wts.name,",...)")))
1181c1177
<   for (i in 1:niter) {
---
>   for (i in seq_len(niter)) {
1197c1193
<   } ## end i in 1:niter
---
>   } ## end i in seq_len(niter)
1220c1216
< { if (inherits(family,"extended.family")) warning("family are not designed for use with gamm!")
---
> { if (inherits(family,"extended.family")) warning("family are not designed for use with 'gamm()' function!")
1234c1230
<       else stop("gamm() can only handle random effects defined as named lists")
---
>       else stop("'gamm()' can only handle random effects defined as named lists")
1249c1245
<         for (i in 1:length(weights)) {
---
>         for (i in seq_len(length(weights))) {
1338c1334
<       for (i in 1:r.m) rand[[n.sr+i]]<-random[[i]]   
---
>       for (i in seq_len(r.m)) rand[[n.sr+i]]<-random[[i]]   
1383c1379
<       if (verbosePQL) cat("\n Maximum number of PQL iterations: ",niterPQL,"\n")
---
>       if (verbosePQL) cat("\n ", gettext("Maximum number of PQL iterations: ", domain = "R-mgcv"), niterPQL, "\n", sep = "")
1420,1421c1416,1417
<     if (G$nsdf) p <- bf[1:G$nsdf] else p <- array(0,0)
<     if (G$m>0) for (i in 1:G$m)
---
>     if (G$nsdf) p <- bf[seq_len(G$nsdf)] else p <- array(0,0)
>     if (G$m>0) for (i in seq_len(G$m))
1431c1427
<           for (j in 1:length(flev)) {
---
>           for (j in seq_len(length(flev))) {
1451c1447
<     if (G$m>0) for (i in 1:G$m) # var.param in reverse term order, but forward order within terms!!
---
>     if (G$m>0) for (i in seq_len(G$m)) # var.param in reverse term order, but forward order within terms!!
1466c1462
<     if (length(spl)) for (i in 1:length(spl)) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
---
>     if (length(spl)) for (i in seq_len(length(spl))) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
1477,1478c1473,1474
<       Xf <- G$Xf[,1:G$nsdf,drop=FALSE] 
<       if (G$m>0) for (i in 1:G$m) {# Accumulate the total model matrix
---
>       Xf <- G$Xf[, seq_len(G$nsdf), drop = FALSE] 
>       if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total model matrix
1487c1483
<           for (k in 1:length(flev)) {
---
>           for (k in seq_len(length(flev))) {
1498c1494
<       if (G$m>0) for (i in 1:G$m) {
---
>       if (G$m>0) for (i in seq_len(G$m)) {
1513c1509
<     if (G$m>0) for (i in 1:G$m) {# Accumulate the total penalty matrix 
---
>     if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total penalty matrix 
1517c1513
<         if (ns) for (l in 1:ns) { 
---
>         if (ns) for (l in seq_len(ns)) { 
1526,1527c1522,1523
<         for (j in 1:length(flev)) {
<            if (ns) for (l in 1:ns) { 
---
>         for (j in seq_len(length(flev))) {
>            if (ns) for (l in seq_len(ns)) { 
1541c1537
<     if (G$m) for (i in 1:G$m) { 
---
>     if (G$m) for (i in seq_len(G$m)) { 
1585c1581
<     if (G$nsdf>0) term.names<-colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>     if (G$nsdf>0) term.names<-colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1588c1584
<       for (i in 1:n.smooth)
---
>       for (i in seq_len(n.smooth))
1638,1640c1634,1636
<     if (fit.cor<.999) { cat("FAILED: fit.cor = ",fit.cor,"\n");return()}
<     if (edf.diff>edf.tol) { cat("FAILED: edf.diff = ",edf.diff,"\n");return()}
<     cat("PASSED \n")
---
>     if (fit.cor<.999) { cat(gettextf("TEST FAILED: fit.cor = %s",fit.cor, domain = "R-mgcv"), "\n", sep = "");return()}
>     if (edf.diff>edf.tol) { cat(gettext("TEST FAILED: edf.diff = %s",edf.diff, domain = "R-mgcv"), "\n", sep = "");return()}
>     cat(gettext("TEST PASSED", domain = "R-mgcv"), "\n", sep = "")
1647c1643
<   cat("testing covariate scale invariance ... ")  
---
>   cat(gettext("testing covariate scale invariance ... ", domain = "R-mgcv"))
1653c1649
<   cat("testing invariance w.r.t. response ... ")
---
>   cat(gettext("testing invariance w.r.t. response ... ", domain = "R-mgcv"))
1658c1654
<   cat("testing equivalence of te(x) and s(x) ... ")
---
>   cat(gettext("testing equivalence of te(x) and s(x) ... ", domain = "R-mgcv"))
1663c1659
<   cat("testing equivalence of gam and gamm with same sp ... ")
---
>   cat(gettext("testing equivalence of gam and gamm with same sp ... ", domain = "R-mgcv"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/jagam.r Recommended/mgcv/R/jagam.r
26c26
<     cat("  for (i in 1:n) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
---
>     cat("  for (i in seq_len(n)) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
30c30
<   cat("  for (i in 1:n) { ",file=file,append=TRUE)
---
>   cat("  for (i in seq_len(n)) { ",file=file,append=TRUE)
50c50
<   } else stop("family not implemented yet")
---
>   } else stop("family not implemented yet") #IVORY
68c68
<   for (i in 1:length(uoff)) {
---
>   for (i in seq_len(length(uoff))) {
81c81
<   rp <- qrx$pivot;rp[rp] <- 1:ncol(X)
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(ncol(X))
96c96
<   if (is.null(file)) stop("jagam requires a file for the JAGS model specification")
---
>   if (is.null(file)) stop("'jagam()' function requires a file for the JAGS model specification")
99c99
<     warning("smoothing parameter prior choise not recognised, reset to gamma")
---
>     warning("smoothing parameter prior choise not recognised, reset to 'gamma'")
177c177
<     ptau <- min(prior.tau[1:G$nsdf]) 
---
>     ptau <- min(prior.tau[seq_len(G$nsdf)]) 
179c179
<     cat("  for (i in 1:",G$nsdf,") { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
---
>     cat("  for (i in seq_len(",G$nsdf,")) { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
193c193
<   for (i in 1:length(G$smooth)) {
---
>   for (i in seq_len(length(G$smooth))) {
204c204
<       if (M>0) for (j in 1:M) {
---
>       if (M>0) for (j in seq_len(M)) {
216c216
<       } else for (j in 1:M) {
---
>       } else for (j in seq_len(M)) {
227c227
<       cat("  ",Kname," <- ",Sname,"[1:",p,",1:",p,"] * lambda[",n.sp+1,"] ",
---
>       cat("  ",Kname," <- ",Sname,"[seq_len(",p,"), seq_len(",p,")] * lambda[",n.sp+1,"] ",
230c230
<         for (j in 2:M) cat(" + ",Sname,"[1:",p,",",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
---
>         for (j in 2:M) cat(" + ",Sname,"[seq_len(",p,"), ",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
248c248
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
254c254
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
269c269
<       cat("  for (i in 1:",nr,") { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
272c272
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
275c275
<       cat("  for (i in 1:",nr,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) {\n",file=file,append=TRUE,sep="")
281c281
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
302c302
<       warning("burnin too large, reset")
---
>       warning(gettextf("'%s' argument is too large, reset", "burnin"))
329c329
<     warning("rho missing from simulation data edf.type reset to 2")
---
>     warning("'rho' slot for 'sam' argument is missing from simulation data, 'edf.type' argument reset to 2")
345c345
<     for (i in 1:length(lambda)) {
---
>     for (i in seq_len(length(lambda))) {
369,372c369,372
<     if ("residuals"%in% arg.names) stop("residuals argument not supported")
<     if ("unconditional"%in% arg.names) stop("unconditional argument not meaningful here")
<     if ("by.resids"%in% arg.names) stop("by.resids argument not supported")
<     if ("all.terms"%in% arg.names) stop("all.terms argument not supported")
---
>     if ("residuals"%in% arg.names) stop(gettextf("'%s' argument is not supported", "residuals"))
>     if ("unconditional"%in% arg.names) stop(gettextf("'%s' argument is not meaningful here", "unconfitional"))
>     if ("by.resids"%in% arg.names) stop(gettextf("'%s' argument is not supported", "by.resids"))
>     if ("all.terms"%in% arg.names) stop(gettextf("'%s' argument is not supported", "all.terms"))
388c388
<     if ("unconditional"%in% arg.names) warning("unconditional argument not meaningful here")
---
>     if ("unconditional"%in% arg.names) warning(gettextf("'%s' argument is not meaningful here", "unconditional"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mgcv.r Recommended/mgcv/R/mgcv.r
33c33
<    if (k<0) stop("argument k must be positive.")
---
>    if (k<0) stop("argument 'k' must be positive")
37c37
<    if (n != ncol(A)) stop("A not square")
---
>    if (n != ncol(A)) stop("matrix 'A' is not square")
70c70
<   for (i in 1:length(na)) {
---
>   for (i in seq_len(length(na))) {
103,106c103,106
<   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)") 
<   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)")
<   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)")
<   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)")
---
>   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)", domain = NA)
>   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)", domain = NA)
>   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)", domain = NA)
>   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)", domain = NA)
108c108
<     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)") 
---
>     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)", domain = NA) 
113c113
<       warning("initial point very close to some inequality constraints")
---
>       warning("initial point is very close to some inequality constraints")
116c116
<       warning("initial parameters very close to inequality constraints")
---
>       warning("initial parameters are very close to inequality constraints")
119,121c119,121
<   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)")  
<   if (length(M$S)!=length(M$off)) stop("M$S and M$off have different lengths")
<   if (length(M$S)!=length(M$sp)) stop("M$sp has different length to M$S and M$off")
---
>   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)", domain = NA) 
>   if (length(M$S)!=length(M$off)) stop(gettextf("'%s' and '%s' components should have the same length", "M$S", "M$off"))
>   if (length(M$S)!=length(M$sp)) stop(gettextf("'%s', '%s' and '%s' components should have the same length", "M$sp", "M$S", "M$off"))
127c127
<   if (m>0) for (i in 1:m)
---
>   if (m>0) for (i in seq_len(m))
160c160
<   if ("[["%in%vn) stop("can't handle [[ in formula")
---
>   if ("[["%in%vn) stop("can't handle '[[' in formula")
163c163
<     vn1 <- if (ii[1]>1) vn[1:(ii[1]-1)]
---
>     vn1 <- if (ii[1]>1) vn[seq_len(ii[1]-1)]
169c169
<       vn1 <- c(vn1,paste(vn[ii[k]+1:n],collapse="$"))
---
>       vn1 <- c(vn1,paste(vn[ii[k]+seq_len(n)],collapse="$"))
213,214c213,214
<   if (length(sp)>0) for (i in 1:length(sp)) {
<     ind <- (1:nt)[as.logical(vtab[sp[i],])]
---
>   if (length(sp)>0) for (i in seq_along(sp)) {
>     ind <- seq_len(nt)[as.logical(vtab[sp[i],])]
217,218c217,218
<   if (length(tp)>0) for (i in 1:length(tp)) {
<     ind <- (1:nt)[as.logical(vtab[tp[i],])]
---
>   if (length(tp)>0) for (i in seq_along(tp)) {
>     ind <- seq_len(nt)[as.logical(vtab[tp[i],])]
221,222c221,222
<   if (length(tip)>0) for (i in 1:length(tip)) {
<     ind <- (1:nt)[as.logical(vtab[tip[i],])]
---
>   if (length(tip)>0) for (i in seq_along(tip)) {
>     ind <- seq_len(nt)[as.logical(vtab[tip[i],])]
225,226c225,226
<   if (length(t2p)>0) for (i in 1:length(t2p)) {
<     ind <- (1:nt)[as.logical(vtab[t2p[i],])]
---
>   if (length(t2p)>0) for (i in seq_along(t2p)) {
>     ind <- seq_len(nt)[as.logical(vtab[t2p[i],])]
229,230c229,230
<   if (length(zp)>0) for (i in 1:length(zp)) {
<     ind <- (1:nt)[as.logical(vtab[zp[i],])]
---
>   if (length(zp)>0) for (i in seq_along(zp)) {
>     ind <- seq_len(nt)[as.logical(vtab[zp[i],])]
245c245
<   if (nt) for (i in 1:nt) { # work through all terms
---
>   if (nt) for (i in seq_len(nt)) { # work through all terms
296c296
<   for (i in 1:length(smooth.spec)) {
---
>   for (i in seq_len(length(smooth.spec))) {
298c298
<     ff1 <- paste(smooth.spec[[i]]$term[1:nt],collapse="+")
---
>     ff1 <- paste(smooth.spec[[i]]$term[seq_len(nt)],collapse="+")
349c349
<     for (i in 1:d) {
---
>     for (i in seq_len(d)) {
377c377
<     for (i in 1:d) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
---
>     for (i in seq_len(d)) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
396c396
<     QtX2[-(1:r),] <- 0
---
>     QtX2[-seq_len(r),] <- 0
398,399c398,399
<     if (rank.def>0) ind <- (1:ncol(X2))[rank(mdiff) <= rank.def] else
<     ind <- (1:ncol(X2))[mdiff < R11*tol]
---
>     if (rank.def>0) ind <- seq_len(ncol(X2))[rank(mdiff) <= rank.def] else
>     ind <- seq_len(ncol(X2))[mdiff < R11*tol]
455c455
<   for (i in 1:m) { ## collect all term names and max smooth `dim'
---
>   for (i in seq_len(m)) { ## collect all term names and max smooth `dim'
484c484
<   for (i in 1:length(sm.id)) sm.id[[i]]<-array(0,0)
---
>   for (i in seq_len(length(sm.id))) sm.id[[i]]<-array(0,0)
486,488c486,488
<   for (d in 1:maxDim) {
<     for (i in 1:m) {
<       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in 1:d) { ## work through terms
---
>   for (d in seq_len(maxDim)) {
>     for (i in seq_len(m)) {
>       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in seq_len(d)) { ## work through terms
500c500
<   if (maxDim==1) warning("model has repeated 1-d smooths of same variable.")
---
>   if (maxDim==1) warning("model has repeated 1-d smooths of same variable")
506c506
<     for (i in 1:m) { ## create parameter indices for each term
---
>     for (i in seq_len(m)) { ## create parameter indices for each term
515,516c515,516
<   for (d in 1:maxDim) { ## work up through dimensions 
<     for (i in 1:m) { ## work through smooths
---
>   for (d in seq_len(maxDim)) { ## work up through dimensions 
>     for (i in seq_len(m)) { ## work through smooths
521c521
<         for (j in 1:d) { ## work through variables
---
>         for (j in seq_len(d)) { ## work through variables
523,524c523,524
<           k <- (1:length(b))[b==i] ## locate current smooth in list 
<           if (k>1) for (l in 1:(k-1)) if (!b[l] %in% X1comp) { ## collect X columns
---
>           k <- (seq_along(b))[b==i] ## locate current smooth in list 
>           if (k>1) for (l in seq_len(k-1)) if (!b[l] %in% X1comp) { ## collect X columns
559c559
<             if (mi>1) for (j in 1:mi) St <- St + 
---
>             if (mi>1) for (j in seq_len(mi)) St <- St + 
589c589
<     } ## end i in 1:m loop
---
>     } ## end i in seq_len(m) loop
591c591
<   if (with.pen) for (i in 1:m) { ## remove working variables that were added
---
>   if (with.pen) for (i in seq_len(m)) { ## remove working variables that were added
603c603
<  if (specb$dim!=spec$dim) stop("`id' linked smooths must have same number of arguments") 
---
>  if (specb$dim!=spec$dim) stop("'id' linked smooths must have same number of arguments") 
610c610
<     for (i in 1:length(specb$margin)) {
---
>     for (i in seq_len(length(specb$margin))) {
612c612
<          for (j in 1:length(specb$margin[[i]]$term)) {
---
>          for (j in seq_len(length(specb$margin[[i]]$term))) {
649c649
<   if (n.t>0) for (j in 1:n.t) if (tind[j]>0) {
---
>   if (n.t>0) for (j in seq_len(n.t)) if (tind[j]>0) {
653c653
<       ind <- (1:length(assign))[assign==tind[j]] ## index of coefs involved here
---
>       ind <- seq_len(length(assign))[assign==tind[j]] ## index of coefs involved here
660,661c660,661
<       if (!is.null(ranki)&&length(ranki)!=np) stop("`rank' has wrong length in `paraPen'") 
<       if (np) for (i in 1:np) { ## unpack penalty matrices, offsets and ranks
---
>       if (!is.null(ranki)&&length(ranki)!=np) stop("'rank' has wrong length in 'paraPen'") 
>       if (np) for (i in seq_len(np)) { ## unpack penalty matrices, offsets and ranks
674c674
<         if (nrow(Li)!=np) stop("L has wrong dimension in `paraPen'")
---
>         if (nrow(Li)!=np) stop("'L' has wrong dimension in 'paraPen'")
682c682
<           if (length(spi)!=ncol(Li)) stop("`sp' dimension wrong in `paraPen'")
---
>           if (length(spi)!=ncol(Li)) stop("'sp' dimension wrong in 'paraPen'")
696,697c696,697
<     if (length(sp0)<length(sp)) stop("`sp' too short")
<     sp0 <- sp0[1:length(sp)]
---
>     if (length(sp0)<length(sp)) stop("'sp' is too short")
>     sp0 <- sp0[seq_len(length(sp))]
746c746
<   ii <- 1:n
---
>   ii <- seq_len(n)
750c750
<   for (i in 1:nf) {
---
>   for (i in seq_len(nf)) {
753c753
<       ind <- pstart[i] + 1:nsdf[i] - 1
---
>       ind <- pstart[i] + seq_len(nsdf[i]) - 1
778c778
<       for (i in 1:nlp) { 
---
>       for (i in seq_len(nlp)) { 
792c792
<                     data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                     data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
799,800c799,800
<   if (!is.null(paraPen)) stop("paraPen not supported for multi-formula models")
<   if (!absorb.cons) stop("absorb.cons must be TRUE for multi-formula models")
---
>   if (!is.null(paraPen)) stop("'paraPen' argument is not supported for multi-formula models")
>   if (!absorb.cons) stop("'absorb.cons' argument must be TRUE for multi-formula models")
803c803
<   if (length(drop.intercept) != d) stop("length(drop.intercept) should be equal to number of model formulas")
---
>   if (length(drop.intercept) != d) stop("'length(drop.intercept)' should be equal to number of model formulas")
817,818c817,818
<   if (!is.null(sp)&&used.sp>0) sp <- sp[-(1:used.sp)] ## need to strip off already used sp's
<   if (!is.null(min.sp)&&nrow(G$L)>0) min.sp <- min.sp[-(1:nrow(G$L))]  
---
>   if (!is.null(sp)&&used.sp>0) sp <- sp[-seq_len(used.sp)] ## need to strip off already used sp's
>   if (!is.null(min.sp)&&nrow(G$L)>0) min.sp <- min.sp[-seq_len(nrow(G$L))]  
823,824c823,824
<   for (i in 1:formula$nlp) lpi[[i]] <- rep(0,0)
<   lpi[[1]] <- 1:ncol(G$X) ## lpi[[j]] is index of cols for jth linear predictor 
---
>   for (i in seq_len(formula$nlp)) lpi[[i]] <- rep(0,0)
>   lpi[[1]] <- seq_len(ncol(G$X)) ## lpi[[j]] is index of cols for jth linear predictor 
842,843c842,843
<     if (!is.null(sp)&&used.sp>0) sp <- sp[-(1:used.sp)] ## need to strip off already used sp's
<     if (!is.null(min.sp)&&nrow(um$L)>0) min.sp <- min.sp[-(1:nrow(um$L))]  
---
>     if (!is.null(sp)&&used.sp>0) sp <- sp[-seq_len(used.sp)] ## need to strip off already used sp's
>     if (!is.null(min.sp)&&nrow(um$L)>0) min.sp <- min.sp[-seq_len(nrow(um$L))]  
847c847
<       lpi[[j]] <- c(lpi[[j]],pof + 1:ncol(um$X)) ## add these cols to lpi[[j]]
---
>       lpi[[j]] <- c(lpi[[j]],pof + seq_len(ncol(um$X))) ## add these cols to lpi[[j]]
852c852
<       stop("shared offsets not allowed")
---
>       stop("shared offsets are not allowed")
864c864
<     if (um$m) for (j in 1:um$m) {
---
>     if (um$m) for (j in seq_len(um$m)) {
881c881
<     if (M) for (j in 1:M) {
---
>     if (M) for (j in seq_len(M)) {
896c896
<     if (um$nsdf>0) um$term.names[1:um$nsdf] <- paste(um$term.names[1:um$nsdf],i-1,sep=".")
---
>     if (um$nsdf>0) um$term.names[seq_len(um$nsdf)] <- paste(um$term.names[seq_len(um$nsdf)],i-1,sep=".")
915c915
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
920c920
<       for (i in 1:length(G$off)) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
---
>       for (i in seq_len(length(G$off))) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
936c936
<                      data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                      data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
1021c1021
<     ind <- 1:length(PP$sp)
---
>     ind <- seq_len(length(PP$sp))
1035c1035
<     if (m>0) for (i in 1:m) attr(split$smooth.spec[[i]],"gamm") <- TRUE
---
>     if (m>0) for (i in seq_len(m)) attr(split$smooth.spec[[i]],"gamm") <- TRUE
1040c1040
<     for (i in 1:m) if (!is.null(split$smooth.spec[[i]]$id)) {
---
>     for (i in seq_len(m)) if (!is.null(split$smooth.spec[[i]]$id)) {
1056c1056
<         for (j in 1:length(temp.term)) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
---
>         for (j in seq_len(length(temp.term))) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
1065c1065
<         for (j in 1:length(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
---
>         for (j in seq_along(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
1074c1074
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1091c1091
<     for (j in 1:length(sml)) {
---
>     for (j in seq_along(sml)) {
1103c1103
<     if (!apply.by) for (i in 1:length(sm)) { ## restore any by-free model matrices
---
>     if (!apply.by) for (i in seq_len(length(sm))) { ## restore any by-free model matrices
1117c1117
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1126c1126
<           if (is.null(Sname)) spn <- paste(sm[[i]]$label,1:length.S,sep="") else
---
>           if (is.null(Sname)) spn <- paste(sm[[i]]$label, seq_len(length.S),sep="") else
1146c1146
<         stop("Later terms sharing an `id' can not have more smoothing parameters than the first such term")
---
>         stop("Later terms sharing an 'id' can not have more smoothing parameters than the first such term")
1159c1159
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1197c1197
<     QtX <- qr.qty(qrx,X)[1:rank,]
---
>     QtX <- qr.qty(qrx,X)[seq_len(rank),]
1199c1199
<       R <- R[1:rank,]
---
>       R <- R[seq_len(rank),]
1236c1236
<       warning("Supplied smoothing parameter vector is too short - ignored.")
---
>       warning("Supplied smoothing parameter vector is too short - ignored")
1240c1240
<       warning("NA's in supplied smoothing parameter vector - ignoring.")
---
>       warning("NA values in supplied smoothing parameter vector - ignoring")
1244c1244
<   G$sp <- if (ok) sp[1:ncol(L)] else rep(-1,ncol(L))
---
>   G$sp <- if (ok) sp[seq_len(ncol(L))] else rep(-1,ncol(L))
1253c1253
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1279,1280c1279,1280
<   if (length(idx)) for (i in 1:length(idx)) idx[[i]]$sp.done <- FALSE
<   if (m>0) for (i in 1:m) { ## work through all smooths
---
>   if (length(idx)) for (i in seq_along(idx)) idx[[i]]$sp.done <- FALSE
>   if (m>0) for (i in seq_len(m)) { ## work through all smooths
1300,1303c1300,1303
<     if (length(min.sp)<nrow(L)) stop("length of min.sp is wrong.")
<     min.sp <- min.sp[1:nrow(L)]
<     if (sum(is.na(min.sp))) stop("NA's in min.sp.")
<     if (sum(min.sp<0)) stop("elements of min.sp must be non negative.")
---
>     if (length(min.sp)<nrow(L)) stop(gettextf("'%s' argument is of the wrong length", "min.sp"))
>     min.sp <- min.sp[seq_len(nrow(L))]
>     if (sum(is.na(min.sp))) stop("NA values in 'min.sp' argument")
>     if (sum(min.sp<0)) stop("elements of 'min.sp' argument must be non negative")
1308c1308
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1311c1311
<     for (j in 1:length(sm$S)) {  # work through penalty matrices
---
>     for (j in seq_along(sm$S)) {  # work through penalty matrices
1337c1337
<       for (i in 1:length(PP$S)) {
---
>       for (i in seq_len(length(PP$S))) {
1353,1354c1353,1354
<     ef0 <- indi <- (1:length(ind))[ind]
<     if (length(indi)>0) for (i in 1:length(indi)) {
---
>     ef0 <- indi <- seq_len(length(ind))[ind]
>     if (length(indi)>0) for (i in seq_len(length(indi))) {
1377c1377
<       for (i in 1:m) {
---
>       for (i in seq_len(m)) {
1400c1400
<   if (G$nsdf > 0) term.names <- colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>   if (G$nsdf > 0) term.names <- colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1403c1403
<   for (i in 1:n.smooth) { ## create coef names, if smooth has any coefs!
---
>   for (i in seq_len(n.smooth)) { ## create coef names, if smooth has any coefs!
1442c1442
<   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method.")
---
>   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method")
1444c1444
<   if (optimizer[2]%in%c("nlm.fd")) .Deprecated(msg=paste("optimizer",optimizer[2],"is deprecated, please use newton or bfgs"))
---
>   if (optimizer[2]%in%c("nlm.fd")) .Deprecated(msg=gettextf("optimizer %s is deprecated, please use newton or bfgs", optimizer[2]))
1630c1630
<   if (length(G$S)>0) for (i in 1:length(G$S)) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
---
>   if (length(G$S)>0) for (i in seq_len(length(G$S))) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
1764c1764
<       ind <- 1:nlsp + nth ## only used if nlsp>0
---
>       ind <- seq_len(nlsp) + nth ## only used if nlsp>0
1788c1788
<     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-(1:nth)] ## drop theta params
---
>     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-seq_len(nth)] ## drop theta params
1855c1855
<    ## if (v.n) for (i in 1:v.n) if (length(dl[[i]])<n) dl[[i]] <- NULL 
---
>    ## if (v.n) for (i in seq_len(v.n)) if (length(dl[[i]])<n) dl[[i]] <- NULL 
1860c1860
<      for (i in 1:v.n) if (length(dl[[i]])>=n) { 
---
>      for (i in seq_len(v.n)) if (length(dl[[i]])>=n) { 
1864c1864
<      if (k>0) v.name <- v.name[1:k] else v.name <- rep("",k)
---
>      if (k>0) v.name <- v.name[seq_len(k)] else v.name <- rep("",k)
1871c1871
<    if (v.n>0) for (i in 1:v.n) {
---
>    if (v.n>0) for (i in seq_len(v.n)) {
1883c1883
<          ii <- min((1:length(lx))[freq==max(freq)])
---
>          ii <- min(seq_len(length(lx))[freq==max(freq)])
1955c1955
<       for (i in 1:length(formula)) {
---
>       for (i in seq_len(length(formula))) {
2012c2012
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2075c2075
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
2079c2079
<   cat("Total model degrees of freedom",sum(x$edf),"\n")
---
>   cat(gettextf("Total model degrees of freedom %s",sum(x$edf), domain = "R-mgcv"), "\n", sep = "")
2082,2083c2082,2083
<     cat("\nEstimated degrees of freedom:\n")
<     for (i in 1:n.smooth)
---
>     cat("\n", gettext("Estimated degrees of freedom:", domain = "R-mgcv"), "\n", sep = "")
>     for (i in seq_len(n.smooth))
2086c2086
<     for (i in 1:n.smooth) {   
---
>     for (i in seq_len(n.smooth)) {   
2090c2090
<     cat(" total =",round(sum(x$edf),digits=2),"\n")
---
>     cat(gettextf(" total df = %s",round(sum(x$edf),digits=2), domain = "R-mgcv"), "\n", sep = "")
2093,2094c2093,2094
<   cat("\n",x$method," score: ",x$gcv.ubre,"     ",sep="")
<   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat("rank: ",x$rank,"/",length(x$coefficients),sep="") 
---
>   cat("\n", gettextf("%s score = %s", sQuote(x$method), x$gcv.ubre, domain = "R-mgcv"), "     ", sep = "")
>   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat(gettextf("Rank: %s/%s", x$rank, length(x$coefficients), domain = "R-mgcv"), sep = "") 
2115,2118c2115,2117
<     if (!is.logical(edge.correct)&&(!is.numeric(edge.correct)||edge.correct<0)) stop(
<         "edge.correct must be logical or a positive number")
<     if (!is.numeric(nthreads) || nthreads <1) stop("nthreads must be a positive integer") 
<     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number.")
---
>     if (!is.logical(edge.correct)&&(!is.numeric(edge.correct)||edge.correct<0)) stop("edge.correct must be logical or a positive number")
>     if (!is.numeric(nthreads) || nthreads <1) stop("'nthreads' argument must be a positive integer") 
>     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number")
2125c2124
<       warning("silly value supplied for rank.tol: reset to square root of machine precision.")
---
>       warning("silly value supplied for rank.tol: reset to square root of machine precision")
2218c2217
<   for (i in 1:length(G$S))
---
>   for (i in seq_len(length(G$S)))
2250c2249
<     if (!olm)  .Deprecated(msg="performance iteration with gam is deprecated, use bam instead")
---
>     if (!olm)  .Deprecated(msg=gettext("performance iteration with gam is deprecated, use bam instead"))
2274c2273
<       for (i in 1:n.S) S.size[i]<-mean(abs(G$S[[i]])) 
---
>       for (i in seq_len(n.S)) S.size[i]<-mean(abs(G$S[[i]])) 
2286c2285
<         stop("illegal `family' argument")
---
>         stop("invalid 'family' argument")
2301c2300
<         stop("y must be univariate unless binomial")
---
>         stop("'y' must be univariate unless binomial")
2309c2308
<     stop(gettextf("Length of start should equal %d and correspond to initial coefs.",nvars)) 
---
>     stop(gettextf("Length of start should equal %d and correspond to initial coefs", nvars))
2329c2328
<     for (iter in 1:(control$maxit)) 
---
>     for (iter in seq_len(control$maxit)) 
2334c2333
<             stop("NAs in V(mu)")
---
>             stop("NA values in V(mu)")
2339c2338
<             stop("NAs in d(mu)/d(eta)")
---
>             stop("NA values in d(mu)/d(eta)")
2363c2362
<         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control.")
---
>         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control")
2401,2402c2400
<             stop("no valid set of coefficients has been found:please supply starting values",
<             call. = FALSE)
---
>             stop("no valid set of coefficients has been found:please supply starting values", call. = FALSE)
2407c2405
<                   stop("inner loop 1; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 1))
2417c2415
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2420c2418
<             warning("Step size truncated: out of bounds.",call.=FALSE)
---
>             warning("Step size truncated: out of bounds",call. = FALSE)
2424c2422
<                   stop("inner loop 2; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 2))
2434c2432
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2505c2503
< { if (!inherits(object,"gam")) stop("`object' is not of class \"gam\"")
---
> { if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
2575c2573
<     warning("Unknown type, reset to terms.")
---
>     warning("Unknown type, reset to terms")
2608,2609c2606
<         if (sum(!(names(object$model)%in%names(newdata)))) stop(
<         "newdata is a model.frame: it should contain all required variables\n")
---
>         if (sum(!(names(object$model)%in%names(newdata)))) stop("newdata is a model.frame: it should contain all required variables\n")
2674c2671
<     for (i in 1:length(newdata)) 
---
>     for (i in seq_len(length(newdata))) 
2679c2676
<         msg <- paste(paste(levn[!levn%in%levm],collapse=", "),"not in original fit",collapse="")
---
>         msg <- gettextf("%s not in original fit", paste(levn[!levn%in%levm], collapse = ", "), domain = "R-mgcv")
2750c2747
<       warning("type iterms not available for multiple predictor cases")
---
>       warning("type 'iterms' is not available for multiple predictor cases")
2756c2753
<     for (i in 1:length(object$nsdf)) {
---
>     for (i in seq_len(length(object$nsdf))) {
2758c2755
<       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+1:object$nsdf[i])
---
>       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+seq_len(object$nsdf[i]))
2764c2761
<     pind <- 1:object$nsdf ## index of parameteric coefficients
---
>     pind <- seq_len(object$nsdf) ## index of parameteric coefficients
2779c2776
<     for (i in 1:length(Terms)) {
---
>     for (i in seq_along(Terms)) {
2795c2792
<   if (n.blocks > 0) for (b in 1:n.blocks) { # work through prediction blocks
---
>   if (n.blocks > 0) for (b in seq_len(n.blocks)) { # work through prediction blocks
2802c2799
<     for (i in 1:length(Terms)) { ## loop for parametric components (1 per lp)
---
>     for (i in seq_len(length(Terms))) { ## loop for parametric components (1 per lp)
2825c2822
<       if (object$nsdf[i]>0) X[,pstart[i]-1 + 1:object$nsdf[i]] <- Xp
---
>       if (object$nsdf[i]>0) X[,pstart[i]-1 + seq_len(object$nsdf[i])] <- Xp
2831c2828
<     if (n.smooth) for (k in 1:n.smooth) { ## loop through smooths
---
>     if (n.smooth) for (k in seq_len(n.smooth)) { ## loop through smooths
2856,2857c2853,2854
<       for (j in 1:length(lass)) if (length(lass[[j]])) { ## work through assign list
<         ind <- 1:length(lass[[j]]) ## index vector for coefs involved
---
>       for (j in seq_len(length(lass))) if (length(lass[[j]])) { ## work through assign list
>         ind <- seq_len(length(lass[[j]])) ## index vector for coefs involved
2859c2856
<         if (nptj>0) for (i in 1:nptj) { ## work through parametric part
---
>         if (nptj>0) for (i in seq_len(nptj)) { ## work through parametric part
2868c2865
<         for (k in 1:n.smooth) # work through the smooth terms 
---
>         for (k in seq_len(n.smooth)) # work through the smooth terms 
2914,2915c2911,2912
<           off.ind <- (1:n.smooth)[as.logical(colSums(abs(Xoff)))]
<           for (j in 1:nlp) { ## looping over the model formulae
---
>           off.ind <- seq_len(n.smooth)[as.logical(colSums(abs(Xoff)))]
>           for (j in seq_len(nlp)) { ## looping over the model formulae
3059c3056
<   if (!inherits(b,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3068c3065
<   for (i in 1:m) { ## loop through smooths
---
>   for (i in seq_len(m)) { ## loop through smooths
3086c3083
<     for (i in 1:m) {
---
>     for (i in seq_len(m)) {
3090c3087
<       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3094c3091
<       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3098c3095
<       conc[2,i] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>       conc[2,i] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3101c3098
<       conc[3,i] <- sum(R[1:r,]^2)/sum(R^2)
---
>       conc[3,i] <- sum(R[seq_len(r),]^2)/sum(R^2)
3107,3108c3104,3105
<     for (i in 1:n.measures) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
<     for (i in 1:m) { ## concurvity calculation loop
---
>     for (i in seq_len(n.measures)) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
>     for (i in seq_len(m)) { ## concurvity calculation loop
3111c3108
<       for (j in 1:m) if (i!=j) { 
---
>       for (j in seq_len(m)) if (i!=j) { 
3113c3110
<         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3117c3114
<         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3121c3118
<         conc[[2]][i,j] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>         conc[[2]][i,j] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3124c3121
<         conc[[3]][i,j] <- sum(R[1:r,]^2)/sum(R^2)
---
>         conc[[3]][i,j] <- sum(R[seq_len(r),]^2)/sum(R^2)
3133c3130
<     for (i in 1:n.measures) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
---
>     for (i in seq_len(n.measures)) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
3167c3164
<       warning("Pearson residuals not available for this family - returning deviance residuals")
---
>       warning("Pearson residuals are not available for this family - returning deviance residuals")
3196c3193
< #    for (i in 1:length(x)) r[i] <- davies(x[i],lambda,h)$Qq
---
> #    for (i in seq_len(length(x))) r[i] <- davies(x[i],lambda,h)$Qq
3200c3197
<   if (length(h) != length(lambda)) stop("lambda and h should have the same length!")
---
>   if (length(h) != length(lambda)) stop(gettextf("'%s' and '%s' arguments should have the same length", "lambda", "h"))
3244c3241
<   p <- (1:nq-.5)/nq
---
>   p <- (seq_len(nq)-.5)/nq
3263c3260
<   if (!inherits(b,"gam")) stop("recov works with fitted gam objects only") 
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3270c3267
<       for (i in 1:length(b$smooth)) { 
---
>       for (i in seq_len(length(b$smooth))) { 
3273c3270
<         if (ns>0) for (j in 1:ns) {
---
>         if (ns>0) for (j in seq_len(ns)) {
3289c3286
<   if (m%in%re) stop("m can't be in re")
---
>   if (m%in%re) stop("'m' argument  can't be in 're' argument")
3293c3290
<   for (i in 1:length(re)) {
---
>   for (i in seq_len(length(re))) {
3299,3300c3296,3297
<   map[rind] <- 1:p2 ## random
<   map[!rind] <- 1:p1 ## fixed
---
>   map[rind] <- seq_len(p2) ## random
>   map[!rind] <- seq_len(p1) ## fixed
3311c3308
<   for (i in 1:length(b$smooth)) { 
---
>   for (i in seq_len(length(b$smooth))) { 
3315c3312
<     if (ns>0) for (j in 1:ns) {
---
>     if (ns>0) for (j in seq_len(ns)) {
3374c3371
<   for (i in 1:length(b$smooth)) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
---
>   for (i in seq_len(length(b$smooth))) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
3432c3429
<   if (k1<ncol(vec)) vec <- vec[,1:k1,drop=FALSE]
---
>   if (k1<ncol(vec)) vec <- vec[,seq_len(k1),drop=FALSE]
3436c3433
<      if (k>1) vec[,1:(k-1)] <- t(t(vec[,1:(k-1)])/sqrt(ed$val[1:(k-1)]))
---
>      if (k>1) vec[,seq_len(k-1)] <- t(t(vec[,seq_len(k-1)])/sqrt(ed$val[seq_len(k-1)]))
3450c3447
<             t(t(vec)/sqrt(ed$val[1:k]))
---
>             t(t(vec)/sqrt(ed$val[seq_len(k)]))
3518c3515
<     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this.")
---
>     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this")
3545c3542
<       for (i in 1:length(object$nsdf)) if (object$nsdf[i]>0) ind <- 
---
>       for (i in seq_len(length(object$nsdf))) if (object$nsdf[i]>0) ind <- 
3547c3544
<     } else { pstart <- 1;ind <- 1:object$nsdf} ## only one lp
---
>     } else { pstart <- 1;ind <- seq_len(object$nsdf)} ## only one lp
3570c3567
<   for (j in 1:length(pterms)) {
---
>   for (j in seq_len(length(pterms))) {
3577c3574
<       ind <- pstart[j] - 1 + 1:np 
---
>       ind <- pstart[j] - 1 + seq_len(np)
3581c3578
<       for (i in 1:nt) { 
---
>       for (i in seq_len(nt)) { 
3632c3629
<         ind <- sample(1:nrow(object$model),sub.samp,replace=FALSE)  ## sample these rows from X
---
>         ind <- sample(seq_len(nrow(object$model)),sub.samp,replace=FALSE)  ## sample these rows from X
3642c3639
<     for (i in 1:m) { ## loop through smooths
---
>     for (i in seq_len(m)) { ## loop through smooths
3673,3674c3670,3671
<       df <- df[1:ii];chi.sq <- chi.sq[1:ii];edf1 <- edf1[1:ii]
<       edf <- edf[1:ii];s.pv <- s.pv[1:ii]
---
>       df <- df[seq_len(ii)];chi.sq <- chi.sq[seq_len(ii)];edf1 <- edf1[seq_len(ii)]
>       edf <- edf[seq_len(ii)];s.pv <- s.pv[seq_len(ii)]
3707c3704
<   cat("Formula:\n") 
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
3709c3706
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3713c3710
<   { cat("\nParametric coefficients:\n")
---
>   { cat("\n", gettext("Parametric coefficients:", domain = "R-mgcv"), "\n", sep = "")
3718c3715
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3722,3724c3719,3721
<   if (!is.null(x$rank) && x$rank< x$np) cat("Rank: ",x$rank,"/",x$np,"\n",sep="") 
<   if (!is.null(x$r.sq)) cat("R-sq.(adj) = ",formatC(x$r.sq,digits=3,width=5),"  ")
<   if (length(x$dev.expl)>0) cat("Deviance explained = ",formatC(x$dev.expl*100,digits=3,width=4),"%",sep="")
---
>   if (!is.null(x$rank) && x$rank< x$np) cat(gettextf("Rank: %s/%s", x$rank, x$np, domain = "R-mgcv"), "\n", sep = "")
>   if (!is.null(x$r.sq)) cat(gettextf("R-sq.(adj) = %s", formatC(x$r.sq,digits=3,width=5), domain = "R-mgcv"), "  ", sep = "")
>   if (length(x$dev.expl)>0) cat(gettextf("Deviance explained = %s %%", formatC(x$dev.expl*100,digits=3,width=4), domain = "R-mgcv"), sep = "")
3729c3726
<   cat("  Scale est. = ",formatC(x$scale,digits=5,width=8,flag="-"),"  n = ",x$n,"\n",sep="")
---
>   cat(gettextf("  Scale est. = %s  n = %s", formatC(x$scale,digits=5,width=8,flag="-"), x$n, domain = "R-mgcv"), "\n", sep = "")
3742,3743c3739
<         warning("The following arguments to anova.glm(..) are invalid and dropped: ",
<             paste(deparse(dotargs[named]), collapse = ", "))
---
>         warning(gettext("The following arguments to anova.glm(..) are invalid and dropped: ", domain = "R-mgcv"), paste(deparse(dotargs[named]), collapse = ", "), domain = NA)
3762c3758
<       for (i in 1:length(dotargs)) {
---
>       for (i in seq_along(dotargs)) {
3773,3774c3769,3770
<     if (!is.null(test)) warning("test argument ignored")
<     if (!inherits(object,"gam")) stop("anova.gam called with non gam object")
---
>     if (!is.null(test)) warning("'test' argument ignored")
>     if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
3785,3786c3781,3782
<   cat("Formula:\n") 
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3789c3785
<   { cat("\nParametric Terms:\n")
---
>   { cat("\n", gettext("Parametric Terms:", domain = "R-mgcv"), "\n", sep = "")
3794c3790
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3808c3804
<   if (!inherits(x,"gam")) stop("not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3813c3809
<   for (i in 1:length(x$smooth)) { ## work through smooths
---
>   for (i in seq_len(length(x$smooth))) { ## work through smooths
3817c3813
<       if (is.null(Snames)) Snames <- as.character(1:length(x$smooth[[i]]$S))
---
>       if (is.null(Snames)) Snames <- as.character(seq_len(length(x$smooth[[i]]$S)))
3819c3815
<       for (j in 1:length(x$smooth[[i]]$S)) {
---
>       for (j in seq_len(length(x$smooth[[i]]$S))) {
3845c3841
<   if (!inherits(x,"gam")) stop("argument is not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3854c3850
<   if (!inherits(x,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3868c3864
<     if (m>0) for (i in 1:m) { ## loop through all smooths
---
>     if (m>0) for (i in seq_len(m)) { ## loop through all smooths
3880,3881c3876,3877
<          warning("S.scale vector doesn't match S list - please report to maintainer")
<         for (j in 1:length(x$smooth[[i]]$S.scale)) {
---
>          warning("'S.scale' vector doesn't match S list - please report to maintainer")
>         for (j in seq_len(length(x$smooth[[i]]$S.scale))) {
3896c3892
<         for (j in 1:length(x$smooth[[ii]]$S.scale)) {
---
>         for (j in seq_len(length(x$smooth[[ii]]$S.scale))) {
3916c3912
<       ind <- 1:x$family$n.theta
---
>       ind <- seq_len(x$family$n.theta)
3948c3944
<     cat(paste("Standard deviations and",conf.lev,"confidence intervals:\n\n"))
---
>     cat(gettextf("Standard deviations and %s confidence intervals:", conf.lev, domain = "R-mgcv"), "\n\n", sep = "")
3950c3946
<     cat("\nRank: ");cat(rank);cat("/");cat(ncol(H));cat("\n")
---
>     cat("\n", gettextf("Rank: %s/%s", rank, ncol(H), domain = "R-mgcv"), "\n", sep = "")
3952c3948
<       cat("\nAll smooth components:\n")
---
>       cat("\n", gettext("All smooth components:", domain = "R-mgcv"), "\n", sep = "")
4027,4028c4023,4024
<     d<-um$d[1:rank]^0.5
<     return(t(t(um$u[,1:rank])*as.vector(d))) # note recycling rule used for efficiency
---
>     d<-um$d[seq_len(rank)]^0.5
>     return(t(t(um$u[,seq_len(rank)])*as.vector(d))) # note recycling rule used for efficiency
4040c4036
<     L <- L[,piv,drop=FALSE]; L <- t(L[1:rank,,drop=FALSE])
---
>     L <- L[,piv,drop=FALSE]; L <- t(L[seq_len(rank),,drop=FALSE])
4043c4039
<   stop("method not recognised.")
---
>   stop("method was not recognised")
4119c4115
<     for (i in 1:length(S)) {
---
>     for (i in seq_along(S)) {
4130c4126
<     for (i in 1:length(S)) {
---
>     for (i in seq_along(S)) {
4168c4164
<       for (i in 1:length(S)) {
---
>       for (i in seq_len(length(S))) {
4199c4195
<     for (i in 1:n.p) { # loop over penalties
---
>     for (i in seq_len(n.p)) { # loop over penalties
4213c4209
<       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite.", i)) 
---
>       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite", i))
4274,4276c4270,4272
<     if (!inherits(L,"matrix")) stop("L must be a matrix.")
<     if (nrow(L)<ncol(L)) stop("L must have at least as many rows as columns.")
<     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("L has inconsistent dimensions.")
---
>     if (!inherits(L,"matrix")) stop("'L' argument must be a matrix")
>     if (nrow(L)<ncol(L)) stop("'L' argument must have at least as many rows as columns")
>     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("'L' argument has inconsistent dimensions")
4283c4279
<   { for (i in 1:n.p) 
---
>   { for (i in seq_len(n.p)) 
4303c4299
<     if (n.p>0) for (i in 1:n.p) { 
---
>     if (n.p>0) for (i in seq_len(n.p)) { 
4320c4316
<     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied w wrong.")
---
>     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied 'w' argument is wrong")
4324c4320
<     { if (length(y)!=length(w)) stop("w different length from y!")
---
>     { if (length(y)!=length(w)) stop("'w' argument has different length from 'y' argument!")
4331c4327
<     if (n!=length(X)) stop("X lost dimensions in magic!!")
---
>     if (n!=length(X)) stop("'X' lost dimensions in magic!!")
4336c4332
<   if (n.p>0) for (i in 1:n.p) { 
---
>   if (n.p>0) for (i in seq_len(n.p)) { 
4364,4365c4360,4361
<   res$R <- matrix(um$X[1:q^2],q,q)
<   res$rV<-matrix(um$rV[1:(um$info[1]*q)],q,um$info[1])
---
>   res$R <- matrix(um$X[seq_len(q)^2],q,q)
>   res$rV<-matrix(um$rV[seq_len(um$info[1]*q)],q,um$info[1])
4377c4373
< } ## magic
---
> }
4385c4381
<   hello <- paste("This is mgcv ",version,". For overview type 'help(\"mgcv-package\")'.",sep="")
---
>   hello <- gettextf("This is mgcv %s. For overview type 'help(\"mgcv-package\")'", paste(version, collapse = ""), domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/misc.r Recommended/mgcv/R/misc.r
11c11
<     if (ncol(mu)!=p||nrow(mu)!=n) stop("mu dimensions wrong")
---
>     if (ncol(mu)!=p||nrow(mu)!=n) stop("'mu' dimensions are wrong")
14c14
<     if (length(mu)!=p) stop("mu dimensions wrong")
---
>     if (length(mu)!=p) stop("'mu' dimensions are wrong")
27c27
<    i <- 1:n
---
>    i <- seq_len(n)
31c31
<    j <- 1:p
---
>    j <- seq_len(p)
33c33
<  if (length(i)>length(j)) i <- i[1:length(j)] else j <- j[1:length(i)]
---
>  if (length(i)>length(j)) i <- i[seq_len(length(j))] else j <- j[1:length(i)]
43c43
<    i <- 1:n
---
>    i <- seq_len(n)
47c47
<    j <- 1:p
---
>    j <- seq_len(p)
49c49
<  if (length(i)>length(j)) i <- i[1:length(j)] else j <- j[1:length(i)]
---
>  if (length(i)>length(j)) i <- i[seq_len(length(j))] else j <- j[seq_len(length(i))]
61c61
<     for (i in 1:n) {
---
>     for (i in seq_len(n)) {
65c65
<         A[i,1:length(b)] <- b
---
>         A[i,seq_len(length(b))] <- b
68c68
<     B <- A[1:k,]
---
>     B <- A[seq_len(k),]
72c72
<   if (oo$info>0) stop("not positive definite")
---
>   if (oo$info>0) stop("matrix is not positive definite")
76c76
<     for (i in 1:k) sdiag(A,i-1) <- B[i,1:(n-i+1)]
---
>     for (i in seq_len(k)) sdiag(A,i-1) <- B[i,seq_len(n-i+1)]
91c91
<   if (oo$info>0) stop("not positive definite")
---
>   if (oo$info>0) stop("matrix is not positive definite")
93c93
<   sd <- oo$sd*ld[1:(n-1)]
---
>   sd <- oo$sd*ld[seq_len(n-1)]
122,123c122,123
<     dH <- list();ind <- 1:(nb*nb)
<     for (i in 1:nsp) { 
---
>     dH <- list();ind <- seq_len(nb*nb)
>     for (i in seq_len(nsp)) { 
149c149
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0)
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0)
166c166
<   if (is.null(drop)) matrix(oo$XWX[1:pt^2],pt,pt) else matrix(oo$XWX[1:pt^2],pt,pt)[-drop,-drop]
---
>   if (is.null(drop)) matrix(oo$XWX[seq_len(pt^2)],pt,pt) else matrix(oo$XWX[1:pt^2],pt,pt)[-drop,-drop]
174c174
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
263c263
<     piv <- 1:ncol(X); piv[qrx$pivot] <- 1:ncol(X)
---
>     piv <- seq_len(ncol(X)); piv[qrx$pivot] <- seq_len(ncol(X))
265c265
<     d <- er$d*0;d[1:rr] <- 1/er$d[1:rr]
---
>     d <- er$d*0;d[seq_len(rr)] <- 1/er$d[seq_len(rr)]
269c269
<     Ri[1:rr,1:rr] <- backsolve(R[1:rr,1:rr],diag(rr))
---
>     Ri[seq_len(rr),seq_len(rr)] <- backsolve(R[seq_len(rr),seq_len(rr)],diag(rr))
400,401c400,401
<     if (is.matrix(a)) { if (nrow(a) != x$r) stop("a has wrong number of rows") }
<     else if (length(a) != x$r) stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$r) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$r) stop("'a' argument has wrong number of rows")
403,404c403,404
<     if (is.matrix(a)) { if (nrow(a) != x$c) stop("a has wrong number of rows") }
<     else if (length(a) != x$c)  stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$c) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$c)  stop("'a' argument has wrong number of rows")
409c409
<   if (tr) return(matrix(oo$a[1:(a.c*x$c)],x$c,a.c)) else
---
>   if (tr) return(matrix(oo$a[seq_len(a.c*x$c)],x$c,a.c)) else
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mvam.r Recommended/mgcv/R/mvam.r
18,19c18,19
<   for (i in 1:length(lpi)) {
<     lpi[[i]] <- 1:length(lpi[[i]]) + k
---
>   for (i in seq_len(length(lpi))) {
>     lpi[[i]] <- seq_len(length(lpi[[i]])) + k
41c41
<       lpi[[length(lpi)+1]] <- 1:nt + max(ip)
---
>       lpi[[length(lpi)+1]] <- seq_len(nt) + max(ip)
50,51c50,51
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
60,61c60,61
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
68,69c68,69
<     for (i in 1:length(lpi)) {
<       ii <- 1:length(lpi[[i]]) + k
---
>     for (i in seq_len(length(lpi))) {
>       ii <- seq_len(length(lpi[[i]])) + k
79c79
<   if (d<2) stop("mvn requires 2 or more dimensional data")
---
>   if (d<2) stop(gettextf("'%s' function requires 2 or more dimensional data", "mvn()"))
81c81
<   for (i in 1:d) {
---
>   for (i in seq_len(d)) {
103c103
<       G$term.names <- c(G$term.names,paste("R",1:ntheta,sep="."))
---
>       G$term.names <- c(G$term.names,paste("R",seq_len(ntheta),sep="."))
112c112
<       for (k in 1:ydim) {
---
>       for (k in seq_len(ydim)) {
129c129
<       ind <- G$family$data$nbeta + 1:(ydim*(ydim+1)/2);
---
>       ind <- G$family$data$nbeta + seq_len(ydim*(ydim+1)/2);
131c131
<       k <- 1;for (i in 1:ydim) for (j in i:ydim) {
---
>       k <- 1;for (i in seq_len(ydim)) for (j in i:ydim) {
177c177
< 	for (i in 1:length(offset)) if (sum(offset[[i]]!=0)) stop("mvn does not yet handle offsets")
---
> 	for (i in seq_along(offset)) if (sum(offset[[i]]!=0)) stop("mvn does not yet handle offsets")
202c202
<       for (i in 1:(m-1)) lpstart[i] <- lpi[[i+1]][1]
---
>       for (i in seq_len(m-1)) lpstart[i] <- lpi[[i+1]][1]
226c226
<         for (i in 1:nsp) { 
---
>         for (i in seq_len(nsp)) { 
233,234c233,234
<         d1H <- list();ind <- 1:(nb*nb)
<         for (i in 1:nsp) { 
---
>         d1H <- list();ind <- seq_len(nb*nb)
>         for (i in seq_len(nsp)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/plots.r Recommended/mgcv/R/plots.r
26c26
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
53c53
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
90c90
<   } else stop("object is not a glm or gam")
---
>   } else stop("'object' argument is not an object of class \"glm\" or \"gam\"")
117c117
<       for (i in 1:rep) { 
---
>       for (i in seq_len(rep)) { 
126c126
<       Dq <- quantile(as.numeric(dm),(1:n - .5)/n) 
---
>       Dq <- quantile(as.numeric(dm),(seq_len(n) - .5)/n) 
142c142
<       for (i in 1:s.rep) { 
---
>       for (i in seq_len(s.rep)) { 
153c153
<   { qqplot(Dq,D,ylab=ylab,xlab="theoretical quantiles",ylim=range(c(lim,D)),
---
>   { qqplot(Dq,D,ylab=ylab,xlab=gettext("theoretical quantiles", domain = "R-mgcv"), ylim=range(c(lim,D)),
157c157
<       if (level>=1) for (i in 1:rep) lines(Dq,dm[,i],col=rep.col) else {
---
>       if (level>=1) for (i in seq_len(rep)) lines(Dq,dm[,i],col=rep.col) else {
182c182
<     ind <- sample(1:n,subsample)
---
>     ind <- sample(seq_len(n), subsample)
187c187
<   for (k in 1:m) { ## work through smooths
---
>   for (k in seq_len(m)) { ## work through smooths
198,199c198,199
<     if (ok && ncol(dat)>nc) dat <- dat[,1:nc,drop=FALSE] ## drop any by variables
<     for (j in 1:nc) if (is.factor(dat[[j]])) ok <- FALSE 
---
>     if (ok && ncol(dat)>nc) dat <- dat[, seq_len(nc), drop = FALSE] ## drop any by variables
>     for (j in seq_len(nc)) if (is.factor(dat[[j]])) ok <- FALSE 
206,207c206,207
<         for (i in 1:n.rep) {
<           e <- diff(rsd[sample(1:nr,nr)]) ## shuffle 
---
>         for (i in seq_len(n.rep)) {
>           e <- diff(rsd[sample(seq_len(nr), nr)]) ## shuffle 
218c218
<           for (i in 1:nc) {
---
>           for (i in seq_len(nc)) {
224c224
<           for (i in 1:nc) { ## rescale distances
---
>           for (i in seq_len(nc)) { ## rescale distances
234,235c234,235
<         for (i in 1:n.rep) {
<           rsdr <- rsd[sample(1:nr,nr)] ## shuffle
---
>         for (i in seq_len(n.rep)) {
>           rsdr <- rsd[sample(seq_len(nr), nr)] ## shuffle
269,271c269,271
<     plot(linpred, resid,main="Resids vs. linear pred.",
<          xlab="linear predictor",ylab="residuals",...)
<     hist(resid,xlab="Residuals",main="Histogram of residuals",...)
---
>     plot(linpred, resid,main=gettext("Resids vs. linear pred.", domain = "R-mgcv"),
>          xlab=gettext("linear predictor", domain = "R-mgcv"), ylab=gettext("Residuals", domain = "R-mgcv"),...)
>     hist(resid,xlab=gettext("Residuals", domain = "R-mgcv"), main=gettext("Histogram of residuals", domain = "R-mgcv"),...)
275c275
<          xlab="Fitted Values",ylab="Response",main="Response vs. Fitted Values",...)
---
>          xlab=gettext("Fitted Values", domain = "R-mgcv"), ylab=gettext("Response", domain = "R-mgcv"), main=gettext("Response vs. Fitted Values", domain = "R-mgcv"),...)
284,285c284,285
<       cat("\n\'gamm\' based fit - care required with interpretation.")
<       cat("\nChecks based on working residuals may be misleading.")
---
>       cat("\n", gettext("'gamm' based fit - care required with interpretation.", domain = "R-mgcv"), sep = "")
>       cat("\n", gettext("Checks based on working residuals may be misleading.", domain = "R-mgcv"), sep = "")
287c287
<       cat("\nMethod:",b$method,"  Optimizer:",b$optimizer)
---
>       cat("\n", gettextf("Method: %s  Optimizer: %s", paste(b$method, collapse = ""), paste(b$optimizer, collapse = ""), domain = "R-mgcv"))
293,294c293,294
<           cat("\nGradient range [",min(boi$grad),",",max(boi$grad),"]",sep="")
<           cat("\n(score ",b$gcv.ubre," & scale ",b$sig2,").",sep="")
---
>           cat("\n", gettextf("Gradient range [%s, %s]", min(boi$grad), max(boi$grad), domain = "R-mgcv"), sep = "")
>           cat("\n", gettextf("(score %s & scale %s).", b$gcv.ubre, b$sig2, domain = "R-mgcv"), sep = "")
296,297c296,297
<           if (min(ev)>0) cat("\nHessian positive definite, ") else cat("\n")
<           cat("eigenvalue range [",min(ev),",",max(ev),"].\n",sep="")
---
>           if (min(ev)>0) cat("\n", gettext("Hessian positive definite", domain = "R-mgcv"), ", ", sep = "") else cat("\n")
>           cat(gettextf("eigenvalue range [%s, %s].", min(ev), max(ev), domain = "R-mgcv"), "\n", sep = "")
303c303
<           cat("\nModel required no smoothing parameter selection")
---
>           cat("\n", gettext("Model required no smoothing parameter selection", domain = "R-mgcv"), sep = "")
305,306c305
<           cat("\nSmoothing parameter selection converged after",b$mgcv.conv$iter,"iteration")       
<           if (b$mgcv.conv$iter>1) cat("s")
---
>           cat("\n", sprintf(ngettext(b$mgcv.conv$iter, "Smoothing parameter selection converged after %d iteration", "Smoothing parameter selection converged after %d iterations", domain = "R-mgcv"), b$mgcv.conv$iter), sep = "")
309,310c308,309
<           cat(" by steepest\ndescent step failure.\n") else cat(".\n")
<           cat("The RMS",b$method,"score gradient at convergence was",b$mgcv.conv$rms.grad,".\n")
---
>           cat(gettext(" by steepest\ndescent step failure.", domain = "R-mgcv"), "\n") else cat(".\n") #LUKI
>           cat(gettextf("The RMS %s score gradient at convergence was %s.", b$method, b$mgcv.conv$rms.grad, domain = "R-mgcv"), "\n", sep = "")
312c311
<           cat("The Hessian was positive definite.\n") else cat("The Hessian was not positive definite.\n")
---
>           cat(gettext("The Hessian was positive definite.", domain = "R-mgcv"), "\n", sep = "") else cat(gettext("The Hessian was not positive definite.", domain = "R-mgcv"), "\n", sep = "")
318c317
<         cat("Model rank = ",b$rank,"/",length(b$coefficients),"\n")
---
>         cat(gettextf("Model rank = %s/%s", b$rank, length(b$coefficients), domain = "R-mgcv"), "\n", sep = "")
325,326c324
<       cat("Basis dimension (k) checking results. Low p-value (k-index<1) may\n") 
<       cat("indicate that k is too low, especially if edf is close to k\'.\n\n")
---
>       cat(gettext("Basis dimension (k) checking results. Low p-value (k-index<1) may\nindicate that k is too low, especially if edf is close to k.", domain = "R-mgcv"), "\n\n", sep = "")
349,350c347,348
<       if (is.null(xlab)) xlabel<- "Gaussian quantiles" else xlabel <- xlab
<       if (is.null(ylab)) ylabel <- "effects" else ylabel <- ylab
---
>       if (is.null(xlab)) xlabel<- gettext("Gaussian quantiles", domain = "R-mgcv") else xlabel <- xlab
>       if (is.null(ylab)) ylabel <- gettext("effects", domain = "R-mgcv") else ylabel <- ylab
549c547
<   ind <- (1:nrow(x))[is.na(rowSums(x))] ## where are the splits?
---
>   ind <- seq_len(nrow(x))[is.na(rowSums(x))] ## where are the splits?
568c566
<   for (i in 1:length(pc)) {
---
>   for (i in seq_len(length(pc))) {
588c586
<      for (i in 1:length(pc)) { 
---
>      for (i in seq_len(length(pc))) { 
596c594
<       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of z and pc must match")
---
>       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of 'z' and 'pc' must match")
612c610
<     for (i in 1:length(pc)) pc[[i]][,2] <- zlim[1] + 
---
>     for (i in seq_len(length(pc))) pc[[i]][,2] <- zlim[1] + 
617c615
<     for (i in 1:length(pc)) {
---
>     for (i in seq_len(length(pc))) {
631c629
<     for (i in 1:n.col) {
---
>     for (i in seq_len(n.col)) {
689c687
<     ind <- 1:P$n
---
>     ind <- seq_len(P$n)
1191c1189
<     warn <- paste("scheme should be a single number, or a vector with",m,"elements")
---
>     warn <- gettextf("scheme should be a single number, or a vector with %d elements", m)
1230c1228
<   if (m>0) for (i in 1:m) { ## work through smooth terms
---
>   if (m>0) for (i in seq_len(m)) { ## work through smooth terms
1282c1280
<   if (m>0) for (i in 1:m) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
---
>   if (m>0) for (i in seq_len(m)) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
1312c1310
<     if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
---
>     if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
1356c1354
<   if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
---
>   if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
1435c1433
<     if (fn>gn) mf<-factor(levels(fac))[1:gn]
---
>     if (fn>gn) mf<-factor(levels(fac))[seq_len(gn)]
1439c1437
<       mf[1:(ln*fn)]<-rep(levels(fac),rep(ln,fn))
---
>       mf[seq_len(ln*fn)]<-rep(levels(fac),rep(ln,fn))
1460c1458
<     for (i in 1:length(v.names)) {
---
>     for (i in seq_len(length(v.names))) {
1477,1478c1475
< 
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
1484c1481
<   for (i in 1:2) if (is.factor(x$var.summary[[view[i]]])) {
---
>   for (i in seq_len(2)) if (is.factor(x$var.summary[[view[i]]])) {
1504c1501
<   for (i in 1:length(x$var.summary)) { 
---
>   for (i in seq_len(length(x$var.summary))) { 
1517,1518c1514,1515
<   if (type=="link") zlab<-paste("linear predictor") ## ignore codetools
<   else if (type=="response") zlab<-type
---
>   if (type=="link") zlab<-gettext("linear predictor", domain = "R-mgcv") ## ignore codetools
>   else if (type=="response") zlab<-gettext("response", domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/smooth.r Recommended/mgcv/R/smooth.r
43c43
<     E <- rep(1,ncol(X));E[1:rank] <- sqrt(er$value[1:rank])
---
>     E <- rep(1,ncol(X));E[seq_len(rank)] <- sqrt(er$value[seq_len(rank)])
48c48
<     av.norm <- mean(col.norm[1:rank])
---
>     av.norm <- mean(col.norm[seq_len(rank)])
73c73
<       ind <- 1:rank
---
>       ind <- seq_len(rank)
96c96
<   D <- er$values[1:rank] 
---
>   D <- er$values[seq_len(rank)]
111c111
<     ind <- 1:rank
---
>     ind <- seq_len(rank)
143c143
<   if (n<4) stop("At least three knots required in call to mono.con.")
---
>   if (n<4) stop("At least three knots required in call passed to 'mono.con()'")
146c146
<   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call to mono.con()")
---
>   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call passed to 'mono.con()'")
158c158
<   if (is.null(x)) stop("x is null")
---
>   if (is.null(x)) stop("'x' argument is null")
167c167
<     for (i in 1:length(x)) {
---
>     for (i in seq_along(x)) {
189c189
<     ## txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=","),")",sep="")
---
>     ## txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=","),")",sep="")
193c193
<     txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=",\"*\","),")",sep="")
---
>     txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=",\"*\","),")",sep="")
217c217
<     for (i in 1:ncol(xo)) {
---
>     for (i in seq_len(ncol(xo))) {
220,221c220,221
<         x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=1:length(xoi),labels=xoi) else 
<                  factor(x[,i],levels=1:length(xoi),labels=xoi)
---
>         x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=seq_along(xoi),labels=xoi) else 
>                  factor(x[,i],levels=seq_along(xoi),labels=xoi)
258c258
<     txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=",\":\","),")",sep="")
---
>     txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=",\":\","),")",sep="")
282c282
<     for (i in 1:ncol(xo)) if (is.factor(xo[,i])) { ## may need to reset factors to factors
---
>     for (i in seq_len(ncol(xo))) if (is.factor(xo[,i])) { ## may need to reset factors to factors
284,285c284,285
<       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=1:length(xoi),labels=xoi) else 
<                factor(x[,i],levels=1:length(xoi),labels=xoi)
---
>       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=seq_len(length(xoi)),labels=xoi) else 
>                factor(x[,i],levels=seq_along(xoi),labels=xoi)
301c301
<   if (min(x)<k1||max(x)>knots[nk]) stop("x out of range")
---
>   if (min(x)<k1||max(x)>knots[nk]) stop("'x' out of range")
380c380
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
393c393
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
412c412
<   { warning("dimension of fx is wrong") 
---
>   { warning("dimension of 'fx' is wrong") 
418c418
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
420c420
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
424c424
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs <- rep("cr",n.bases) }
430c430
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
440c440
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
459c459
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
494c494
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
507c507
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
526c526
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
528c528
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
532c532
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs<-rep("cr",n.bases) }
538c538
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
548c548
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
562c562
<       warning("ord is wrong. reset to NULL.")
---
>       warning("ord is wrong. reset to NULL")
575c575
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
608c608
<   if (by.var==".") stop("by=. not allowed")
---
>   if (by.var==".") stop("'by=.' is not allowed")
610c610
<   if (term[1]==".") stop("s(.) not supported.")
---
>   if (term[1]==".") stop("'s(.)' function is not yet supported")
614c614
<     if (term[i]==".") stop("s(.) not yet supported.")
---
>     if (term[i]==".") stop("'s(.)' function is not yet supported")
616c616
<   for (i in 1:d) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(d)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
620c620
<   if (all.equal(k.new,k)!=TRUE) {warning("argument k of s() should be integer and has been rounded")}
---
>   if (all.equal(k.new,k)!=TRUE) {warning("argument 'k' of 's()' function should be integer and has been rounded")}
631c631
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
661c661
<     for (j in 1:ncol(X[[i]]))
---
>     for (j in seq_len(ncol(X[[i]])))
694c694
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
700c700
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
727c727
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
731c731
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
745c745
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
760,761c760,761
<     g <- list(); for (i in 1:length(km)) g[[i]] <- object$margin[[km[i]]]$g.index
<     for (i in 1:length(object$margin)) {
---
>     g <- list(); for (i in seq_along(km)) g[[i]] <- object$margin[[km[i]]]$g.index
>     for (i in seq_along(object$margin)) {
768c768
<   if (object$np) for (i in 1:m) { # reparameterize 
---
>   if (object$np) for (i in seq_len(m)) { # reparameterize
797c797
<   for (i in 1:m)  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
---
>   for (i in seq_len(m))  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
825c825
<     #for (i in 1:length(S)) {
---
>     #for (i in seq_along(S)) {
830c830
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
837c837
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
861c861
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
864c864
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
870c870
<   for (i in 1:mxp) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
---
>   for (i in seq_len(mxp)) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
892c892
<   Zi <- Xm[[1]][,1:rank[1],drop=FALSE] ## range space basis for first margin
---
>   Zi <- Xm[[1]][,seq_len(rank[1]),drop=FALSE] ## range space basis for first margin
903c903
<       colnames(Xi) <- as.character(1:ncol(Xi)) 
---
>       colnames(Xi) <- as.character(seq_len(ncol(Xi))) 
914c914
<     Zi <- Xm[[i]][,1:rank[i],drop=FALSE]   ## margin i range space
---
>     Zi <- Xm[[i]][,seq_len(rank[i]),drop=FALSE]   ## margin i range space
918c918
<       if (full) colnames(Xi)  <- as.character(1:ncol(Xi))
---
>       if (full) colnames(Xi)  <- as.character(seq_len(ncol(Xi)))
925c925
<     for (ii in 1:length(X1)) { ## form products with Zi
---
>     for (ii in seq_len(length(X1))) { ## form products with Zi
928c928
<         for (j in 1:ncol(X1[[ii]])) A <- cbind(A,X1[[ii]][,j]*Zi)
---
>         for (j in seq_len(ncol(X1[[ii]]))) A <- cbind(A,X1[[ii]][,j]*Zi)
936c936
<         for (j in 1:ncol(X1[[ii]])) {
---
>         for (j in seq_len(ncol(X1[[ii]]))) {
947c947
<       for (ii in 1:length(X1)) { ## form products with Xi
---
>       for (ii in seq_len(length(X1))) { ## form products with Xi
954c954
<           for (j in 1:ncol(X1[[ii]])) { 
---
>           for (j in seq_len(ncol(X1[[ii]]))) { 
966c966
<            for (j in 1:ncol(Xi)) {
---
>            for (j in seq_len(ncol(Xi))) {
1010c1010
<   for (i in 1:m) { ## create marginal model matrices and penalties...
---
>   for (i in seq_len(m)) { ## create marginal model matrices and penalties...
1014c1014
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
1026c1026
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
1037c1037
<     dS <- rep(0,ncol(Xm[[i]]));dS[1:r[i]] <- 1;
---
>     dS <- rep(0,ncol(Xm[[i]]));dS[seq_len(r[i])] <- 1;
1056c1056
<   if (nsc>0) for (j in 1:nsc) {
---
>   if (nsc>0) for (j in seq_len(nsc)) {
1078c1078
<   nup <- sum(sub.cols[1:nsc]) ## range space rank
---
>   nup <- sum(sub.cols[seq_len(nsc)]) ## range space rank
1084,1085c1084,1085
<     ##  X.shift <- colMeans(X[,1:nup])
<     ##  X[,1:nup] <- sweep(X[,1:nup],2,X.shift) ## make penalized columns orthog to constant col.
---
>     ##  X.shift <- colMeans(X[,seq_len(nup)])
>     ##  X[,seq_len(nup)] <- sweep(X[,seq_len(nup)],2,X.shift) ## make penalized columns orthog to constant col.
1100c1100
<   object$rank <- sub.cols[1:nsc] ## ranks of individual penalties
---
>   object$rank <- sub.cols[seq_len(nsc)] ## ranks of individual penalties
1112c1112
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
1115c1115
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
1126c1126
<   ind <- 1:ncol(object$S[[1]])                   ## index of penalty columns 
---
>   ind <- seq_len(ncol(object$S[[1]]))                   ## index of penalty columns 
1131c1131
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
1171c1171
<   for (i in 1:m) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
---
>   for (i in seq_len(m)) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
1175c1175
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
1179c1179
<       for (j in 1:length(smi)) {
---
>       for (j in seq_len(length(smi))) {
1197c1197
< { if (sum(d<0)) stop("d can not be negative in call to null.space.dimension().")
---
> { if (sum(d<0)) stop("'d' can not be negative in call passed to 'null.space.dimension()'")
1229c1229
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1241c1241
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
1252c1252
<   warning("more knots than data in a tp term: knots ignored.")}
---
>   warning("more knots than data in a tp term: knots ignored")}
1267c1267
<       ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>       ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
1320c1320
<   object$UZ<-matrix(oo$UZ[1:UZ.len],oo$n.Xu+M,k)         # truncated basis matrix
---
>   object$UZ<-matrix(oo$UZ[seq_len(UZ.len)],oo$n.Xu+M,k)         # truncated basis matrix
1322c1322
<   object$Xu<-matrix(oo$Xu[1:Xu.len],oo$n.Xu,object$dim)  # unique covariate combinations
---
>   object$Xu<-matrix(oo$Xu[seq_len(Xu.len)],oo$n.Xu,object$dim)  # unique covariate combinations
1330c1330
<     ind <- 1:(k-M)
---
>     ind <- seq_len(k-M)
1363c1363
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1376c1376
<   ind <- 1:object$bs.dim
---
>   ind <- seq_len(object$bs.dim)
1435,1436c1435
<   { msg <- paste(object$term," has insufficient unique values to support ",
<                  nk," knots: reduce k.",sep="")
---
>   { msg <- gettextf("%s has insufficient unique values to support %d knots: reduce k", object$term, nk)
1537,1538c1536,1537
<   lbi<-floor(delta*1:(nk-2))+1 # lower interval bound index
<   frac<-delta*1:(nk-2)+1-lbi # left over proportion of interval  
---
>   lbi<-floor(delta*seq_len(nk-2))+1 # lower interval bound index
>   frac<-delta*seq_len(nk-2)+1-lbi # left over proportion of interval  
1554c1553
<     h<-x[2:n]-x[1:(n-1)]
---
>     h<-x[2:n]-x[seq_len(n-1)]
1630c1629
<     h<-knots[2:n]-knots[1:(n-1)]
---
>     h<-knots[2:n]-knots[seq_len(n-1)]
1682c1681
<     stop(paste("there should be ",nk," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied", nk))
1685c1684
<   if (length(k)!=nk) stop(paste("there should be",nk,"knots supplied"))
---
>   if (length(k)!=nk) stop(gettextf("there should be %d knots supplied", nk))
1700,1702c1699,1701
<     for (i in 1:p.ord) De <- diff(De)
<     D <- De[,-(1:p.ord)]
<     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,1:p.ord]
---
>     for (i in seq_len(p.ord)) De <- diff(De)
>     D <- De[,-seq_len(p.ord)]
>     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,seq_len(p.ord)]
1752c1751
<     stop(paste("there should be ",nk+2*m[1]+2," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied",nk+2*m[1]+2))
1764c1763
<     B <- matrix(as.numeric(rep(1:p,p)>=rep(1:p,each=p)),p,p) ## coef summation matrix
---
>     B <- matrix(as.numeric(rep(seq_len(p),p)>=rep(seq_len(p),each=p)),p,p) ## coef summation matrix
1875c1874
<     stop(paste("there should be ",nk+2*m[1]," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied", nk+2*m[1]))
1890c1889
<   k0 <- k[m[1]+1:nk] ## the interior knots
---
>   k0 <- k[m[1]+seq_len(nk)] ## the interior knots
1894c1893
<   for (i in 1:length(m2)) { ## loop through penalties
---
>   for (i in seq_along(m2)) { ## loop through penalties
1911c1910
<       i1 <- rep(1:(pord+1),pord+1)+rep(1:(pord+1),each=pord+1) ## i + j
---
>       i1 <- rep(seq_len(pord+1),pord+1)+rep(seq_len(pord+1),each=pord+1) ## i + j
1917c1916
<       i1 <- c(rep(1:pord,length(h)) + rep(0:(length(h)-1) * (pord+1),each=pord),length(ld0))
---
>       i1 <- c(rep(seq_len(pord),length(h)) + rep(0:(length(h)-1) * (pord+1),each=pord),length(ld0))
1924c1923
<       for (k in 1:pord) { ## create the other diagonals...
---
>       for (k in seq_len(pord)) { ## create the other diagonals...
1981c1980
<   for (i in 1:length(object$term)) if (is.factor(data[[object$term[i]]])) { 
---
>   for (i in seq_len(length(object$term))) if (is.factor(data[[object$term[i]]])) { 
2005c2004
<   for (i in 1:object$dim) if (object$term[i]!=fterm) {
---
>   for (i in seq_len(object$dim)) if (object$term[i]!=fterm) {
2031c2030
<   for (i in 1:null.d) { ## create null space element penalties
---
>   for (i in seq_len(null.d)) { ## create null space element penalties
2064c2063
<     for (i in 1:null.d) { ## null space penalties
---
>     for (i in seq_len(null.d)) { ## null space penalties
2118c2117
<   for (i in 1:length(object$flev)) {
---
>   for (i in seq_len(length(object$flev))) {
2130c2129
< ## sets M[i[k],j[k]] <- m[k] for all k in 1:length(m) without
---
> ## sets M[i[k],j[k]] <- m[k] for all k in seq_len(length(m)) without
2149,2151c2148,2150
<   Ind <- matrix(1:(ni*nj),ni,nj) ## the indexing matrix
<   rmt <- rep(1:ni,nj) ## the row index
<   cmt <- rep(1:nj,rep(ni,nj)) ## the column index
---
>   Ind <- matrix(seq_len(ni*nj),ni,nj) ## the indexing matrix
>   rmt <- rep(seq_len(ni),nj) ## the row index
>   cmt <- rep(seq_len(nj),rep(ni,nj)) ## the column index
2153c2152
<   ci <- Ind[2:(ni-1),1:nj] ## column index
---
>   ci <- Ind[2:(ni-1),seq_len(nj)] ## column index
2159,2163c2158,2162
<   Drr <- mfil(Drr,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:(ni-2),1:nj] 
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[3:ni,1:nj]
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## forward coefficient
---
>   Drr <- mfil(Drr,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni-2),seq_len(nj)] 
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[3:ni,seq_len(nj)]
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## forward coefficient
2166c2165
<   ci <- Ind[1:ni,2:(nj-1)] ## column index
---
>   ci <- Ind[seq_len(ni),2:(nj-1)] ## column index
2172,2176c2171,2175
<   Dcc <- mfil(Dcc,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:ni,1:(nj-2)]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[1:ni,3:nj]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## forward coefficient
---
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni),seq_len(nj-2)]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[seq_len(ni),3:nj]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## forward coefficient
2185,2186c2184,2185
<   ci <- Ind[1:(ni-2),1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## -- coefficient
---
>   ci <- Ind[seq_len(ni-2),seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## -- coefficient
2188,2192c2187,2191
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## ++ coefficient
<   ci <- Ind[1:(ni-2),3:nj] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## -+ coefficient
<   ci <- Ind[3:ni,1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## +- coefficient
---
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## ++ coefficient
>   ci <- Ind[seq_len(ni-2),3:nj] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## -+ coefficient
>   ci <- Ind[3:ni,seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## +- coefficient
2210c2209
<   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates.")
---
>   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates")
2231c2230
<       x <- 1:(nk-2)/nk;m=2
---
>       x <- seq_len(nk-2)/nk;m=2
2243c2242
<      # for (i in 1:k) D[[i]] <- as.numeric(V[,i])*Db
---
>      # for (i in seq_len(k)) D[[i]] <- as.numeric(V[,i])*Db
2246c2245
<       for (i in 1:k) {
---
>       for (i in seq_len(k)) {
2262c2261
<       for (i in 1:2) {
---
>       for (i in seq_len(2)) {
2308c2307
<         for (i in 1:kp.tot) {
---
>         for (i in seq_len(kp.tot)) {
2341c2340
<   if (!is.null(object$id)) stop("random effects don't work with ids.")
---
>   if (!is.null(object$id)) stop("random effects don't work with ids")
2351c2350
<     for (i in 1:object$dim) {
---
>     for (i in seq_len(object$dim)) {
2361c2360
<       ind <- 1:ns;ind[maxi] <- ns ;ind[ns] <- maxi
---
>       ind <- seq_len(ns);ind[maxi] <- ns ;ind[ns] <- maxi
2364c2363
<       for (i in 1:ns) object$term <- c(object$term,object$margin[[i]]$term)
---
>       for (i in seq_len(ns)) object$term <- c(object$term,object$margin[[i]]$term)
2377,2378c2376,2377
<     for (i in 1:length(object$S)) { 
<       if (ncol(object$S[[i]])!=object$bs.dim||nrow(object$S[[i]])!=object$bs.dim) stop("supplied S matrices are wrong diminsion")
---
>     for (i in seq_len(length(object$S))) { 
>       if (ncol(object$S[[i]])!=object$bs.dim||nrow(object$S[[i]])!=object$bs.dim) stop("supplied S matrices are wrong dimension")
2434c2433
<   for (i in 1:n.poly) {
---
>   for (i in seq_len(n.poly)) {
2449c2448
<   for (i in 1:length(pc)) nb[[i]] <- rep(0,0)
---
>   for (i in seq_len(length(pc))) nb[[i]] <- rep(0,0)
2451c2450
<   for (k in 1:n.poly) { ## work through poly list looking for neighbours
---
>   for (k in seq_len(n.poly)) { ## work through poly list looking for neighbours
2457c2456
<     ind <- (1:n.poly)[ol] ## index of potential neighbours of poly k
---
>     ind <- seq_len(n.poly)[ol] ## index of potential neighbours of poly k
2460c2459
<     if (length(ind)>0) for (j in 1:length(ind)) {
---
>     if (length(ind)>0) for (j in seq_len(length(ind))) {
2469c2468
<   for (i in 1:length(pc)) nb[[i]] <- unique(nb[[i]])
---
>   for (i in seq_len(length(pc))) nb[[i]] <- unique(nb[[i]])
2526,2527c2525,2526
<       for (i in 1:length(d.name)) {
<         ind <- (1:length(a.name))[a.name==d.name[i]] ## index of duplicates 
---
>       for (i in seq_along(d.name)) {
>         ind <- seq_along(a.name)[a.name==d.name[i]] ## index of duplicates 
2532c2531
<       ind <- (1:length(a.name))[duplicated(a.name)]
---
>       ind <- seq_along(a.name)[duplicated(a.name)]
2559c2558
<     for (i in 1:np) {
---
>     for (i in seq_len(np)) {
2563c2562
<       if (lind>0) for (j in 1:lind) S[a.name[i],a.name[ind[j]]] <- -1
---
>       if (lind>0) for (j in seq_len(lind)) S[a.name[i],a.name[ind[j]]] <- -1
2592c2591
<       for (i in 1:length(mi)) object$X[i,mi[i]] <- 1
---
>       for (i in seq_len(length(mi))) object$X[i,mi[i]] <- 1
2598c2597
<     object$X <- if (length(mi)) rp$X[-(1:length(mi)),ind] else  rp$X[,ind] ## model matrix
---
>     object$X <- if (length(mi)) rp$X[-seq_len(length(mi)),ind] else  rp$X[,ind] ## model matrix
2745c2744
<   for (i in 1:2) {
---
>   for (i in seq_len(2)) {
2755c2754
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
2767c2766
<     warning("more knots than data in an sos term: knots ignored.")
---
>     warning("more knots than data in an sos term: knots ignored")
2784c2783
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
2803c2802
<   R <- makeR(la=knt[1:nk],lo=knt[-(1:nk)],lak=knt[1:nk],lok=knt[-(1:nk)],m=object$p.order)
---
>   R <- makeR(la=knt[seq_len(nk)],lo=knt[-seq_len(nk)],lak=knt[seq_len(nk)],lok=knt[-seq_len(nk)],m=object$p.order)
2805c2804
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
2858c2857
<   lak <- object$knt[1:nk];lok <- object$knt[-(1:nk)] ## knots
---
>   lak <- object$knt[seq_len(nk)];lok <- object$knt[-seq_len(nk)] ## knots
2862,2863c2861,2862
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
2911c2910
<   for (i in 1:M) {
---
>   for (i in seq_len(M)) {
2913c2912
<     for (j in 1:n) y <- y * x[,j]^p[i,j]
---
>     for (j in seq_len(n)) y <- y * x[,j]^p[i,j]
2921c2920
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
2952c2951
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2962c2961
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
2974c2973
<     warning("more knots than data in a ds term: knots ignored.")
---
>     warning("more knots than data in a ds term: knots ignored")
2994c2993
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
3048c3047
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
3102c3101
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3115,3116c3114,3115
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3148c3147
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
3186c3185
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3196c3195
<     for (i in 1:object$dim) { 
---
>     for (i in seq_len(object$dim)) { 
3228c3227
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
3267c3266
<     D[1:k,1:k] <- E  ## penalty
---
>     D[seq_len(k),seq_len(k)] <- E  ## penalty
3293c3292
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3306,3307c3305,3306
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3412c3411
<    for (i in 1:length(object$term)) { 
---
>    for (i in seq_len(length(object$term))) { 
3424c3423
<          for (i in 1:m) dat[[i]] <- X[,i]     ## return only unique rows
---
>          for (i in seq_len(m)) dat[[i]] <- X[,i]     ## return only unique rows
3463c3462
<   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute.")
---
>   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute")
3499c3498
<         drop <- min((1:length(vcol))[vcol==min(vcol)])
---
>         drop <- min(seq_len(length(vcol))[vcol==min(vcol)])
3506c3505
<             sm$C <- ((1:length(xsd))[xsd==0])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xsd))[xsd==0])[1] ## index of coef to set to zero
3511c3510
<             sm$C <- ((1:length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
3550c3549
<       for (i in 1:length(sm$S)) {
---
>       for (i in seq_len(length(sm$S))) {
3570c3569
<     if (!is.null(sm$by.done)) warning("handling `by' variables in smooth constructors may not work with the summation convention ")
---
>     if (!is.null(sm$by.done)) warning("handling 'by' variables in smooth constructors may not work with the summation convention")
3622c3621
<      for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>      for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3635c3634
<       if (matrixArg) stop("factor `by' variables can not be used with matrix arguments.")
---
>       if (matrixArg) stop("factor 'by' variables can not be used with matrix arguments")
3642c3641
<       for (j in 1:length(lev)) {
---
>       for (j in seq_len(length(lev))) {
3655c3654
<           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("`by' variable must be same dimension as smooth arguments")
---
>           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("'by' variable must be same dimension as smooth arguments")
3662c3661
<           ind <- 1:n 
---
>           ind <- seq_len(n)
3672c3671
<             ind <- 1:n 
---
>             ind <- seq_len(n)
3685c3684
<           for (i in 1:n) { ## in this case have to work down the rows
---
>           for (i in seq_len(n)) { ## in this case have to work down the rows
3720c3719
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3725c3724
<           for (l in 1:length(sml[[i]]$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sml[[i]]$S))) { # some smooths have > 1 penalty 
3736c3735
<         indi <- (1:ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
---
>         indi <- seq_len(ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
3742c3741
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3744c3743
<             for (l in 1:length(sm$S)) # some smooths have > 1 penalty 
---
>             for (l in seq_len(length(sm$S))) # some smooths have > 1 penalty 
3746c3745
<               if (nz>0) ZSZ[indi[1:nz],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
---
>               if (nz>0) ZSZ[indi[seq_len(nz)],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
3748c3747
<               if (nz>0) ZSZ[,indi[1:nz]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
---
>               if (nz>0) ZSZ[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
3754c3753
<             if (nz>0) sml[[i]]$X[,indi[1:nz]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
---
>             if (nz>0) sml[[i]]$X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
3770c3769
<         #    for (i in 1:length(sml)) { ## loop through smooth list
---
>         #    for (i in seq_along(sml)) { ## loop through smooth list
3775c3774
<         #      for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>         #      for (l in seq_along(sm$S)) { # some smooths have > 1 penalty 
3782c3781
<             for (i in 1:length(sml)) { ## loop through smooth list
---
>             for (i in seq_len(length(sml))) { ## loop through smooth list
3784c3783
<               for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>               for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3794c3793
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3804c3803
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3810c3809
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3812c3811
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3825c3824
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3827c3826
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3843c3842
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3850c3849
<   } else for (i in 1:length(sml)) attr(sml[[i]],"qrc") <-NULL ## no absorption
---
>   } else for (i in seq_len(length(sml))) attr(sml[[i]],"qrc") <-NULL ## no absorption
3891c3890
<         if (p>rank) for (i in 1:length(sml)) {
---
>         if (p>rank) for (i in seq_len(length(sml))) {
3902c3901
<       if (length(sml[[1]]$S)>1) for (i in 1:length(sml[[1]]$S)) St <- St + sml[[1]]$S[[i]]
---
>       if (length(sml[[1]]$S)>1) for (i in seq_len(length(sml[[1]]$S))) St <- St + sml[[1]]$S[[i]]
3909c3908
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3919c3918
<   if (!apply.by) for (i in 1:length(sml)) {
---
>   if (!apply.by) for (i in seq_along(sml)) {
3940c3939
<     if (!deriv&&!is.null(object$margin)) for (i in 1:length(object$margin))
---
>     if (!deriv&&!is.null(object$margin)) for (i in seq_along(object$margin))
3957c3956
<     for (i in 1:n) { ## in this case have to work down the rows
---
>     for (i in seq_len(n)) { ## in this case have to work down the rows
3981c3980
<           if (length(by)!=nrow(X)) stop("`by' variable must be same dimension as smooth arguments")
---
>           if (length(by)!=nrow(X)) stop("'by' variable must be same dimension as smooth arguments")
3993c3992
<       ind <- 1:n 
---
>       ind <- seq_len(n)
4032c4031
<             if (nz>0) X[ind,indi[1:nz]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
---
>             if (nz>0) X[ind,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
4036c4035
<             if (nz>0) X[,indi[1:nz]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
---
>             if (nz>0) X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/soap.r Recommended/mgcv/R/soap.r
14c14
<     for (i in 1:length(beta.full)) {
---
>     for (i in seq_len(length(beta.full))) {
41c41
<           for (i in 1:length(beta.full)) {
---
>           for (i in seq_len(length(beta.full))) {
60c60
<         beta <- c(beta[1:(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
---
>         beta <- c(beta[seq_len(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
66c66
<         beta <- c(beta[1:(qrc-1)],0,beta[qrc:length(beta)])
---
>         beta <- c(beta[seq_len(qrc-1)],0,beta[qrc:length(beta)])
107c107
<   if (is.null(bnd.name)) for (i in 1:length(bnd)) { 
---
>   if (is.null(bnd.name)) for (i in seq_len(length(bnd))) { 
131c131
< { for (i in 1:length(bnd)) {
---
> { for (i in seq_len(length(bnd))) {
133c133
<     if (length(y)!=n) stop("x and y not same length")
---
>     if (length(y)!=n) stop("'x' and 'y' components of 'bnd' argument are not of same length")
142c142
<     len <- c(0,sqrt((x[1:(n-1)]-x[2:n])^2+(y[1:(n-1)]-y[2:n])^2)) ## seg lengths
---
>     len <- c(0,sqrt((x[seq_len(n-1)]-x[2:n])^2+(y[seq_len(n-1)]-y[2:n])^2)) ## seg lengths
157c157
<   for (k in 1:nk) {
---
>   for (k in seq_len(nk)) {
163c163
<         str <- paste("knot",k,"is on or outside boundary")
---
>         str <- gettextf("knot %d is on or outside boundary", k)
177c177
<   if (!inherits(bnd,"list")) stop("bnd must be a list.")
---
>   if (!inherits(bnd,"list")) stop("bnd must be a list")
181c181
<     else stop("lengths of k and bnd are not compatible.") 
---
>     else stop("lengths of 'k' and 'bnd' arguments are inconsistent") 
224c224
<   ind <- 1:o1$n
---
>   ind <- seq_len(o1$n)
239c239
<   for (i in 1:length(bnd)) {
---
>   for (i in seq_len(length(bnd))) {
255c255
<       bc[[i]] <- list(bsm=bsm,X=bsm$X[1:ret$nb[i],],S=bsm$S[[1]],free.bound=TRUE)
---
>       bc[[i]] <- list(bsm=bsm,X=bsm$X[seq_len(ret$nb[i]),],S=bsm$S[[1]],free.bound=TRUE)
292c292
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
318c318
<       gind[G[ind]] <- (1:length(G))[ind]
---
>       gind[G[ind]] <- seq_len(length(G))[ind]
350c350
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
360c360
<         for (j in 1:ncol(sd$bc[[i]]$X)) { ## loop over loop basis cols
---
>         for (j in seq_len(ncol(sd$bc[[i]]$X))) { ## loop over loop basis cols
384c384
<     for (i in 1:nc) g[sd$ki[i],i] <- 1
---
>     for (i in seq_len(nc)) g[sd$ki[i],i] <- 1
393c393
<     for (i in 1:nc) {
---
>     for (i in seq_len(nc)) {
433c433
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
446c446
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
467c467
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) 
471c471
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
478c478
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
490c490
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
508c508
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
537c537
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
550c550
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
572c572
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) { 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) { 
582c582
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
589c589
<   if (length(b$S)>0) for (i in  1:length(b$S)) {
---
>   if (length(b$S)>0) for (i in  seq_len(length(b$S))) {
601c601
<     if (length(b$S)>0) for (i in 1:length(b$S)) {
---
>     if (length(b$S)>0) for (i in seq_len(length(b$S))) {
614c614
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
642c642
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
655c655
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
675c675
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
686c686
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
703c703
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
766c766
<                 for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>                 for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
802c802
<           for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>           for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/sparse.r Recommended/mgcv/R/sparse.r
14c14
<   ## ni[1:off[1]] gives neighbours of point 1. 
---
>   ## ni[seq_len(off[1])] gives neighbours of point 1. 
16c16
<   return(list(ni = oo$T[1:oo$off[n]]+1,off=oo$off))
---
>   return(list(ni = oo$T[seq_len(oo$off[n])]+1,off=oo$off))
33,34c33,34
<   ii <- c(1:n,oo$ii[1:ni]+1) ## row index
<   jj <- c(1:n,oo$ni[1:ni]+1) ## col index
---
>   ii <- c(seq_len(n),oo$ii[seq_len(ni)]+1) ## row index
>   jj <- c(seq_len(n),oo$ni[seq_len(ni)]+1) ## col index
37,39c37,39
<   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni],dims=c(n,n))
<   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+ni],dims=c(n,n))
<   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+2*ni],dims=c(n,n))
---
>   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)],dims=c(n,n))
>   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+ni],dims=c(n,n))
>   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+2*ni],dims=c(n,n))
112c112
<   lo <- dd[,1:d];hi <- dd[,1:d+d]
---
>   lo <- dd[,seq_len(d)];hi <- dd[,seq_len(d)+d]
123c123
<   for (i in 1:nb) {
---
>   for (i in seq_len(nb)) {
144c144
<   } else { Xu <- X; ind <- 1:nrow(X)}
---
>   } else { Xu <- X; ind <- seq_len(nrow(X))}
150c150
<   if (get.a) a <- 1:n else a=1
---
>   if (get.a) a <- seq_len(n) else a=1
156,157c156,157
<   rind <- 1:nobs
<   rind[ind] <- 1:nobs
---
>   rind <- seq_len(nobs)
>   rind[ind] <- seq_len(nobs)
258c258
<   P <- sparseMatrix(i=1:n,j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
---
>   P <- sparseMatrix(i=seq_len(n),j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
298,299c298,299
<     for (i in 1:nb) {
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) {
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
304c304
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
329c329
<   if (block==0) block <- 1:object$nblock
---
>   if (block==0) block <- seq_len(object$nblock)
367c367
<   } else for (i in 1:object$nblock) { ## work through all blocks 
---
>   } else for (i in seq_len(object$nblock)) { ## work through all blocks 
399,400c399,400
<     for (i in 1:nb) { 
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) { 
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
404c404
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
Only in R-recommended/mgcv/inst/po: ko
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/Tweedie.Rd Recommended/mgcv/man/Tweedie.Rd
80c80
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/coxph.Rd Recommended/mgcv/man/coxph.Rd
59c59
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/gam.Rd Recommended/mgcv/man/gam.Rd
283c283
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/gam.convergence.Rd Recommended/mgcv/man/gam.convergence.Rd
68c68
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/gaulss.Rd Recommended/mgcv/man/gaulss.Rd
36c36
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/gevlss.Rd Recommended/mgcv/man/gevlss.Rd
39c39
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/mgcv-package.Rd Recommended/mgcv/man/mgcv-package.Rd
97c97
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/multinom.Rd Recommended/mgcv/man/multinom.Rd
37c37
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/mvn.Rd Recommended/mgcv/man/mvn.Rd
37c37
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/negbin.Rd Recommended/mgcv/man/negbin.Rd
77c77
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/ocat.Rd Recommended/mgcv/man/ocat.Rd
43c43
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/scat.Rd Recommended/mgcv/man/scat.Rd
41c41
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/ziP.Rd Recommended/mgcv/man/ziP.Rd
51c51
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/man/ziplss.Rd Recommended/mgcv/man/ziplss.Rd
45c45
< \url{http://dx.doi.org/10.1080/01621459.2016.1180986}
---
> \url{https://doi.org/10.1080/01621459.2016.1180986}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/general.h Recommended/mgcv/src/general.h
3,8d2
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("mgcv", String)
< #else
< #define _(String) (String)
< #endif
Only in Recommended/mgcv/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/magic.c Recommended/mgcv/src/magic.c
27a28
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mat.c Recommended/mgcv/src/mat.c
61a62
> #include "localization.h"
87c88
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
109c110
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
117c118
<    if (j!= *r * *c)  Rprintf("\nfile dim problem\n");
---
>    if (j != *r * *c)  Rprintf(_("\nfile dim problem\n"));
3210c3211
<     if (k) Rprintf("Non orthogonal eigenvectors %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Non orthogonal eigenvectors %d %g\n"), k, x / k);
3215c3216
<     if (k) Rprintf("Eigenvectors not normalized %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Eigenvectors not normalized %d %g\n"), k, x / k);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/matrix.c Recommended/mgcv/src/matrix.c
32a33
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/misc.c Recommended/mgcv/src/misc.c
25a26
> #include "localization.h"
31c32
<     Rprintf("adjusting %d memory allocation\n",nmemb);
---
>     Rprintf(_("adjusting %d memory allocation\n"), nmemb);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mvn.c Recommended/mgcv/src/mvn.c
15,16c15,16
<             int *m,double *ll,double *lb,double *lbb,double *dbeta,
<             double *dH,int *deriv,int *nsp,int *nt) {
---
> int *m, double *ll, double *lb, double *lbb, double *dbeta, double *dH,
> 		int *deriv, int *nsp, int *nt) {
31,33c31,35
<   double *R,*theta,ldetR,*Xl,*bl,oned=1.0,zerod=0.0,*p,*p1,*p2,*p3,xx,zz,yy,*yty,
<     *mu,*Rymu,rip,*dtheta,*db,*deriv_theta,*yX,*yRX;
<   int i,j,k,l,pl,one=1,bt,ct,nb,*din,ntheta,ncoef,*rri,*rci,ri,rj,ril,rjl,rik,rjk,rij,rjj,q,r;
---
> 	double *R, *theta, ldetR, *Xl, *bl, oned = 1.0, zerod = 0.0, *p, *p1, *p2,
> 			*p3, xx, zz, yy, *yty, *mu, *Rymu, rip, *dtheta, *db, *deriv_theta,
> 			*yX, *yRX;
> 	int i, j, k, l, pl, one = 1, bt, ct, nb, *din, ntheta, ncoef, *rri, *rci,
> 			ri, rj, ril, rjl, rik, rjk, rij, rjj, q, r;
35c37,38
<   ntheta = *m * (*m+1)/2;ncoef = lpi[*m-1];
---
> 	ntheta = *m * (*m + 1) / 2;
> 	ncoef = lpi[*m - 1];
47,48c50,53
<     R[i + *m * i] = deriv_theta[k];ldetR += theta[k];
<     rri[k]=rci[k]=i;k++; 
---
> 		R[i + *m * i] = deriv_theta[k];
> 		ldetR += theta[k];
> 		rri[k] = rci[k] = i;
> 		k++;
52c57,59
<       rri[k]=i;rci[k]=j;k++;
---
> 			rri[k] = i;
> 			rci[k] = j;
> 			k++;
58,60c65,76
<     if (l==0) { Xl = X;pl = lpi[0];bl=beta;} /* Xl is lth model matrix with pl columns, coef vec bl */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];bl = beta + lpi[l-1];}   
<     F77_CALL(dgemv)(&not_trans,n,&pl,&oned,Xl,n, bl, &one,&zerod, mu, &one); /* BLAS call for mu = Xl bl */
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 			bl = beta;
> 		} /* Xl is lth model matrix with pl columns, coef vec bl */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 			bl = beta + lpi[l - 1];
> 		}
> 		F77_CALL(dgemv)(&not_trans, n, &pl, &oned, Xl, n, bl, &one, &zerod, mu,
> 				&one); /* BLAS call for mu = Xl bl */
62c78,79
<     for (p=mu,p1= mu + *n,p2=y+l;p<p1;p++,p2 += *m) *p2 -= *p;
---
> 		for (p = mu, p1 = mu + *n, p2 = y + l; p < p1; p++, p2 += *m)
> 			*p2 -= *p;
69c86,88
<   bt=0;ct=0;mgcv_pmmult(Rymu,R,y,&bt,&ct,m,n,m,nt);  
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_pmmult(Rymu, R, y, &bt, &ct, m, n, m, nt);
71c90,91
<   for (*ll=0.0,p=Rymu,p1=p + *n * *m;p<p1;p++) *ll += *p * *p;
---
> 	for (*ll = 0.0, p = Rymu, p1 = p + *n * *m; p < p1; p++)
> 		*ll += *p * *p;
79,80c99,106
<     if (l==0) { Xl = X;pl = lpi[0];} /* Xl is lth model matrix with pl columns */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];} 
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 		} /* Xl is lth model matrix with pl columns */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 		}
85c111,113
<         for (p1=R + l * *m,p2 = p1 + l,p3 = Rymu + *m *j;p1<=p2;p1++,p3++) *p += xx * *p1 * *p3; 
---
> 				for (p1 = R + l * *m, p2 = p1 + l, p3 = Rymu + *m * j; p1 <= p2;
> 						p1++, p3++)
> 					*p += xx * *p1 * *p3;
94c122,123
<     xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */;
---
> 		xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */
> 		;
98c127,129
<     for (zz=0.0,l=0,p1 = Rymu+i,p2=y+i;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2 * xx;
---
> 		for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + i; l < *n;
> 				l++, p1 += *m, p2 += *m)
> 			zz += *p1 * *p2 * xx;
103c134,136
<       for (zz=0.0,l=0,p1 = Rymu+i,p2=y+j;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2;
---
> 			for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + j; l < *n; l++, p1 +=
> 					*m, p2 += *m)
> 				zz += *p1 * *p2;
113c146,147
<     if (i==lpi[k]) k++; 
---
> 		if (i == lpi[k])
> 			k++;
117,118c151,154
<   for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
<      l=din[i];k=din[j]; /* note l>=k */
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j <= i; j++) {
> 			l = din[i];
> 			k = din[j]; /* note l>=k */
120c156,158
<      for (p=R+l * *m,p1=R+k * *m,rip=0.0,p2=p1+k;p1<=p2;p++,p1++) rip += *p * *p1;
---
> 			for (p = R + l * *m, p1 = R + k * *m, rip = 0.0, p2 = p1 + k;
> 					p1 <= p2; p++, p1++)
> 				rip += *p * *p1;
124c162,163
<   for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j < ntheta; j++) {
131c170,173
<      if (l==rj) for (p = X + i* *n,p1=Rymu+ri,p2=p + *n;p<p2;p++,p1 += *m) xx += *p * *p1;
---
> 			if (l == rj)
> 				for (p = X + i * *n, p1 = Rymu + ri, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					xx += *p * *p1;
135c177,179
<        for (yy=0.0,p = X + i* *n,p1=y+rj,p2=p + *n;p<p2;p++,p1 += *m) yy += *p * *p1;
---
> 				for (yy = 0.0, p = X + i * *n, p1 = y + rj, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					yy += *p * *p1;
141c185,186
<   for (k=0;k<ntheta;k++) for (l=0;l<=k;l++) {
---
> 	for (k = 0; k < ntheta; k++)
> 		for (l = 0; l <= k; l++) {
144c189,190
<         ri=rri[k];rj=rci[k];
---
> 				ri = rri[k];
> 				rj = rci[k];
147c193,195
<           for (zz=0.0,i=0,p=Rymu+ri,p2=y+ri;i<*n;i++,p += *m,p2+= *m) zz += *p * *p2;
---
> 					for (zz = 0.0, i = 0, p = Rymu + ri, p2 = y + ri; i < *n;
> 							i++, p += *m, p2 += *m)
> 						zz += *p * *p2;
152c200,201
<       ri=rri[k];rj=rci[k];
---
> 			ri = rri[k];
> 			rj = rci[k];
155,156c204,207
<       ril=rri[l];rjl=rci[l];
<       rik=rri[k];rjk=rci[k];
---
> 			ril = rri[l];
> 			rjl = rci[l];
> 			rik = rri[k];
> 			rjk = rci[k];
158c209,211
< 	for (yy=0.0,i=0,p=y+rjl,p1=y+rjk;i<*n;i++,p+= *m, p1+= *m) yy += *p * *p1;
---
> 				for (yy = 0.0, i = 0, p = y + rjl, p1 = y + rjk; i < *n;
> 						i++, p += *m, p1 += *m)
> 					yy += *p * *p1;
160c213,214
<         if (ril==rjl) yy *= deriv_theta[l];
---
> 				if (ril == rjl)
> 					yy *= deriv_theta[l];
163c217,218
<       lbb[k + ncoef + nb * (l+ncoef)] = lbb[l + ncoef + nb * (k+ncoef)] = xx;
---
> 			lbb[k + ncoef + nb * (l + ncoef)] =
> 					lbb[l + ncoef + nb * (k + ncoef)] = xx;
170c225,227
<     bt=0;ct=0;mgcv_pmmult(yX,y,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */   
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yX, y, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
172c229,231
<     bt=0;ct=0;mgcv_pmmult(yRX,Rymu,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */  
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yRX, Rymu, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
174c233,235
<     bt=0;ct=1;mgcv_pmmult(yty,y,y,&bt,&ct,m,m,n,nt); /* rows, cols dim */  
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_pmmult(yty, y, y, &bt, &ct, m, m, n, nt); /* rows, cols dim */
181,183c242,248
<       for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
< 	l = din[i];k = din[j]; /* dimensions for these elements */
< 	xx=0.0;p=R+l* *m;p1=R+k* *m;
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j <= i; j++) {
> 					l = din[i];
> 					k = din[j]; /* dimensions for these elements */
> 					xx = 0.0;
> 					p = R + l * *m;
> 					p1 = R + k * *m;
185,187c250,255
<           ri=rri[q];rj=rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
<           if (rj==l) xx += p1[ri]*deriv_theta[q]*dtheta[q];
<           if (rj==k) xx += p[ri]*deriv_theta[q]*dtheta[q];
---
> 						ri = rri[q];
> 						rj = rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
> 						if (rj == l)
> 							xx += p1[ri] * deriv_theta[q] * dtheta[q];
> 						if (rj == k)
> 							xx += p[ri] * deriv_theta[q] * dtheta[q];
194c262,263
<       for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {  
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j < ntheta; j++) {
199c268,269
<           ri=rri[j];rj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 						ri = rri[j];
> 						rj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
201,202c271,276
<           if (rj==l) xx += -R[ri + *m * k]*zz*XX[i + ncoef * q] * db[q];
<           if (rj==k) xx += -R[ri + *m * l]*zz*XX[i + ncoef * q] * db[q];
---
> 						if (rj == l)
> 							xx += -R[ri + *m * k] * zz * XX[i + ncoef * q]
> 									* db[q];
> 						if (rj == k)
> 							xx += -R[ri + *m * l] * zz * XX[i + ncoef * q]
> 									* db[q];
205c279,280
<         rij=rri[j];rjj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 					rij = rri[j];
> 					rjj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
208c283,284
<           rik=rri[k];rjk=rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
---
> 						rik = rri[k];
> 						rjk = rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
210,211c286,291
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
217c297,299
<           if (k==j&&rik==rjk) xx += dtheta[k]* deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rik == rjk)
> 							xx += dtheta[k] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
223,224c305,310
<       for (j=0;j<ntheta;j++) for (k=j;k<ntheta;k++) {
<         rij=rri[j];rjj=rci[j];rik=rri[k];rjk=rci[k];
---
> 			for (j = 0; j < ntheta; j++)
> 				for (k = j; k < ntheta; k++) {
> 					rij = rri[j];
> 					rjj = rci[j];
> 					rik = rri[k];
> 					rjk = rci[k];
228c314,315
< 	  zz=0.0;l=din[i];
---
> 						zz = 0.0;
> 						l = din[i];
230,231c317,322
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
236c327,328
<               if (l==rjj) zz +=  deriv_theta[k] * yRX[rjj + *m * i];  /* x_i^l'R_tt^jk R(y-mu) */
---
> 								if (l == rjj)
> 									zz += deriv_theta[k] * yRX[rjj + *m * i]; /* x_i^l'R_tt^jk R(y-mu) */
240c332,334
<           if (k==j&&rij==rjj) xx +=  db[i]*deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rij == rjj)
> 							xx += db[i] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
243,246c337,348
< 	  ri = rri[i];rj=rci[i];zz=0.0;
<           if (j==k&&ri==rij&&rjk==rik) zz += deriv_theta[j]*deriv_theta[i]*yty[rj * *m + rjj];  /* row rjj, col rj */ 
<           if (i==k&&rik==rij&&rj==ri) zz += deriv_theta[j]*deriv_theta[i]*yty[rjk * *m + rjj];  /* row rjj, col rjk */ 
<           if (i==j&&rik==rij&&rj==ri) zz += deriv_theta[k]*deriv_theta[i]*yty[rjk * *m + rj];  /* row rjk, col rj */ 
---
> 						ri = rri[i];
> 						rj = rci[i];
> 						zz = 0.0;
> 						if (j == k && ri == rij && rjk == rik)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rj * *m + rjj]; /* row rjj, col rj */
> 						if (i == k && rik == rij && rj == ri)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rjk * *m + rjj]; /* row rjj, col rjk */
> 						if (i == j && rik == rij && rj == ri)
> 							zz += deriv_theta[k] * deriv_theta[i]
> 									* yty[rjk * *m + rj]; /* row rjk, col rj */
249c351,353
<             for (yy=0.0,p=Rymu+ri,p1=y+ri,q=0;q<*n;p+= *m,p1+= *m,q++) yy += *p * *p1;           
---
> 							for (yy = 0.0, p = Rymu + ri, p1 = y + ri, q = 0;
> 									q < *n; p += *m, p1 += *m, q++)
> 								yy += *p * *p1;
254c358,359
< 	dH[k + ncoef + (j+ncoef) * nb] = dH[j+ncoef + (k+ncoef) * nb] = xx;
---
> 					dH[k + ncoef + (j + ncoef) * nb] = dH[j + ncoef
> 							+ (k + ncoef) * nb] = xx;
259c364,366
<     FREE(yX);FREE(yRX);FREE(yty);
---
> 		FREE(yX);
> 		FREE(yRX);
> 		FREE(yty);
262,265c369,375
< 
<   FREE(din); FREE(rri); FREE(rci);
<   
<   FREE(R);FREE(Rymu);FREE(deriv_theta);
---
> 	FREE(din);
> 	FREE(rri);
> 	FREE(rci);
> 
> 	FREE(R);
> 	FREE(Rymu);
> 	FREE(deriv_theta);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/qp.c Recommended/mgcv/src/qp.c
29a30,31
> #include "localization.h"
> #include <R_ext/Minmax.h>
32,35d33
< 
< 
< #define max(a,b)    (((a) > (b)) ? (a) : (b))
< #define min(a,b)    (((a) < (b)) ? (a) : (b))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/sparse-smooth.c Recommended/mgcv/src/sparse-smooth.c
24a25
> #include "localization.h"
157c158
<     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf("More than 2 points in a box!!\n");ok=0;}
---
>     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf(_("More than 2 points in a box!!\n"));ok=0;}
162c163
<     if (count[i]!=1) { Rprintf("point %d in %d boxes!\n",i,count[i]);ok=0;}
---
>     if (count[i]!=1) { Rprintf(_("point %d in %d boxes!\n"),i,count[i]);ok=0;}
164c165
<   if (ok) Rprintf("kd tree sanity checks\n");
---
>   if (ok) Rprintf(_("kd tree sanity checks\n"));
324c325
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
340c341
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
356c357
<   if (bi!=nb-1) Rprintf("bi not equal to nb-1 %d %d\n",bi,nb-1);
---
>   if (bi!=nb-1) Rprintf(_("bi not equal to nb-1 %d %d\n"),bi,nb-1);
666c667
<       if (!check) Rprintf("indexing error in p_area!\n");
---
>       if (!check) Rprintf(_("indexing error in p_area!\n"));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.c Recommended/mgcv/src/tprs.c
25a26
> #include "localization.h"
39,40c38,41
<   d2 = d/2;m2 = 2*m;
<   if (m2 <= d) error(_("You must have 2m>d for a thin plate spline."));
---
> 	d2 = d / 2;
> 	m2 = 2 * m;
> 	if (m2 <= d)
> 		error(_("You must have 2m>d for a thin plate spline."));
42,46c43,55
<   { if ((m+1+d2)%2) f= -1.0; else f=1.0; /* finding (-1)^{m+1+d/2} */
<     for (i=0;i<m2-1;i++) f/=2;  /* dividing by 2^{2m-1} */
<     for (i=0;i<d2;i++) f/=pi;  /* dividing by pi^{d/2} */
<     for (i=2;i<m;i++) f/=i; /* dividing by (m-1)! */
<     for (i=2;i<=m-d2;i++) f/=i; /* dividing by (m-d/2)! */
---
> 	{
> 		if ((m + 1 + d2) % 2)
> 			f = -1.0;
> 		else
> 			f = 1.0; /* finding (-1)^{m+1+d/2} */
> 		for (i = 0; i < m2 - 1; i++)
> 			f /= 2; /* dividing by 2^{2m-1} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi; /* dividing by pi^{d/2} */
> 		for (i = 2; i < m; i++)
> 			f /= i; /* dividing by (m-1)! */
> 		for (i = 2; i <= m - d2; i++)
> 			f /= i; /* dividing by (m-d/2)! */
48c57,58
<   { f=Ghalf;
---
> 	{
> 		f = Ghalf;
50,52c60,65
<     for (i=0;i<k;i++) f/= -0.5-i; /* f = gamma function of d/2-m */
<     for (i=0;i<m;i++) f/= 4; /* divide by 2^{2m} */
<     for (i=0;i<d2;i++) f/=pi;
---
> 		for (i = 0; i < k; i++)
> 			f /= -0.5 - i; /* f = gamma function of d/2-m */
> 		for (i = 0; i < m; i++)
> 			f /= 4; /* divide by 2^{2m} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi;
54c67,68
<     for (i=2;i<m;i++) f/=i;  /* divide by (m-1)! */
---
> 		for (i = 2; i < m; i++)
> 			f /= i; /* divide by (m-1)! */
63c77,78
<   if (r<=0.0) return(0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
---
> 	if (r <= 0.0)
> 		return (0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
66c81,82
<     for (i=0;i<m-d2;i++) f *= r; /* r^2m-d (noting r is really r^2) */
---
> 		for (i = 0; i < m - d2; i++)
> 			f *= r; /* r^2m-d (noting r is really r^2) */
68c84,85
<     for (i=0;i<m-d2-1 ;i++) f *= r; /* note r really r^2 */
---
> 		for (i = 0; i < m - d2 - 1; i++)
> 			f *= r; /* note r really r^2 */
79c96,97
< { int i,j,k,Xr,Xc;
---
> {
> 	int i, j, k, Xr, Xc;
84,86c102,107
<   XMi = X->M;Xr = X->r;Xc = X->c;
<   for (i=0;i<Xr;i++,XMi++) for (XMj = X->M,j=0;j<i;j++,XMj++)
<   { r=0.0;
---
> 	XMi = X->M;
> 	Xr = X->r;
> 	Xc = X->c;
> 	for (i = 0; i < Xr; i++, XMi++)
> 		for (XMj = X->M, j = 0; j < i; j++, XMj++) {
> 			r = 0.0;
107c127,128
< { int *index,i,j,sum;
---
> {
> 	int *index, i, j, sum;
109,110c130
<   for (i=0;i < *M;i++)
<   { /* copy index to pi */
---
> 	for (i = 0; i < *M; i++) { /* copy index to pi */
112c132,133
<     for (j=0;j< *d;j++) pi[i + *M * j]=index[j];
---
> 		for (j = 0; j < *d; j++)
> 			pi[i + *M * j] = index[j];
114c135,137
<     sum=0;for (j=0;j< *d;j++) sum += index[j];
---
> 		sum = 0;
> 		for (j = 0; j < *d; j++)
> 			sum += index[j];
118c141,142
<     { sum -= index[0];
---
> 		{
> 			sum -= index[0];
120,123c144,151
<       for (j=1;j< *d;j++)
<       { index[j]++;sum++;
<         if (sum== *m) { sum-=index[j];index[j]=0;}
<         else break; /* problem resolved! */
---
> 			for (j = 1; j < *d; j++) {
> 				index[j]++;
> 				sum++;
> 				if (sum == *m) {
> 					sum -= index[j];
> 					index[j] = 0;
> 				} else
> 					break; /* problem resolved! */
138c165,166
< { int M,i,j,k,*pin,z;
---
> {
> 	int M, i, j, k, *pin, z;
141,142c169,172
<   for (i=0;i<d;i++) M*=d+m-1-i;
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d+1)!/(d!(m-d!) */
152,154c182,186
<   for (j=0;j<M;j++)
<   { x=1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
<     for (k=0;k<d;k++) for (z=0;z<pin[j + M * k];z++) x *= X->M[i][k];
---
> 		for (j = 0; j < M; j++) {
> 			x = 1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
> 			for (k = 0; k < d; k++)
> 				for (z = 0; z < pin[j + M * k]; z++)
> 					x *= X->M[i][k];
169,170c200,206
< { int M,i;
<   if (2*m<=d) {m=1;while (2*m<d+2) m++;} 
---
> {
> 	int M, i;
> 	if (2 * m <= d) {
> 		m = 1;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
172,173c208,211
<   for (i=0;i<d;i++) M*=d+m-1-i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */ 
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d-1)!/(d!(m-1)!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d-1)!/(d!(m-1)!) */
177,178c215,216
< 
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant)
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant)
200c238,239
< { static int sd=0,sm=0,*pin,M;
---
> {
> 	static int sd = 0, sm = 0, *pin, M;
204,205c243,249
<   if (sd==0&&d==0) return(0.0); /* There is nothing to clear up and nothing to calculate */
<   if (2*m<=d&&d>0) { m=0;while (2*m<d+2) m++;} 
---
> 	if (sd == 0 && d == 0)
> 		return (0.0); /* There is nothing to clear up and nothing to calculate */
> 	if (2 * m <= d && d > 0) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
207,209c251,256
<   { if (sd>0&&sm>0) 
<     { /*for (i=0;i<M;i++) FREE(pin[i]);*/ FREE(pin);}
<     sd=d;sm=m;
---
> 	{
> 		if (sd > 0 && sm > 0) { /*for (i=0;i<M;i++) FREE(pin[i]);*/
> 			FREE(pin);
> 		}
> 		sd = d;
> 		sm = m;
211,213c258,263
<     { M=1;     /* dimension of penalty null space */
<       for (i=0;i<d;i++) M*=d+m-1-i;
<       for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 		{
> 			M = 1; /* dimension of penalty null space */
> 			for (i = 0; i < d; i++)
> 				M *= d + m - 1 - i;
> 			for (i = 2; i <= d; i++)
> 				M /= i; /* M = (m+d+1)!/(d!(m-d!) */
219c269,270
<     } else return(0.0);
---
> 		} else
> 			return (0.0);
221,224c272,282
<   g=0.0;XM=X->M;n = X->r;
<   for (pb=b,i=0;i<n;i++,pb++)
<   { r=0.0;XMi=XM[i];
<     for (dum=x;dum<x+d;dum++) { z= *XMi - *dum;XMi++;r+=z*z;}
---
> 	g = 0.0;
> 	XM = X->M;
> 	n = X->r;
> 	for (pb = b, i = 0; i < n; i++, pb++) {
> 		r = 0.0;
> 		XMi = XM[i];
> 		for (dum = x; dum < x + d; dum++) {
> 			z = *XMi - *dum;
> 			XMi++;
> 			r += z * z;
> 		}
227c285,286
<     if (p->r) g += *pb *p->V[i];
---
> 		if (p->r)
> 			g += *pb * p->V[i];
231c290,291
<   { r=1.0;
---
> 	{
> 		r = 1.0;
234c294,296
<     for (j=0;j<d;j++) for (k=0;k<pin[i+M*j];k++)  r*=x[j];
---
> 		for (j = 0; j < d; j++)
> 			for (k = 0; k < pin[i + M * j]; k++)
> 				r *= x[j];
236c298,299
<     if (p->r) g+=p->V[i+n-off]*r;
---
> 		if (p->r)
> 			g += p->V[i + n - off] * r;
245,246c308,312
< { int i;
<   for (i=0;i<k;i++) if (a[i]!=b[i]) return(0);
---
> {
> 	int i;
> 	for (i = 0; i < k; i++)
> 		if (a[i] != b[i])
> 			return (0);
267c333,334
< { int *yxindex,start,stop,ok,i;
---
> {
> 	int *yxindex, start, stop, ok, i;
272,276c339,343
<   start=stop=0;ok=1;
<   while(ok)
<   { /* look for start of run of equal rows ..... */
<     while(start<Xd->r-1&&!Xd_row_comp(Xd->M[start],Xd->M[start+1],Xd->c-1)) 
<     { /* Xd->M[start] not tied with anything, nothing to erase.... */
---
> 	start = stop = 0;
> 	ok = 1;
> 	while (ok) { /* look for start of run of equal rows ..... */
> 		while (start < Xd->r - 1
> 				&& !Xd_row_comp(Xd->M[start], Xd->M[start + 1], Xd->c - 1)) { /* Xd->M[start] not tied with anything, nothing to erase.... */
281,282c348,349
<     if (start==Xd->r-1) 
<     { ok=0; /* reached end with no more ties */
---
> 		if (start == Xd->r - 1) {
> 			ok = 0; /* reached end with no more ties */
287,288c354,358
<     { stop=start+1;
<       while(stop<Xd->r-1&&Xd_row_comp(Xd->M[stop],Xd->M[stop+1],Xd->c-1)) stop++;
---
> 		{
> 			stop = start + 1;
> 			while (stop < Xd->r - 1
> 					&& Xd_row_comp(Xd->M[stop], Xd->M[stop + 1], Xd->c - 1))
> 				stop++;
290c360,361
<       { xi=Xd->M[i][Xd->c-1];
---
> 			{
> 				xi = Xd->M[i][Xd->c - 1];
294,295c365,367
<       for (i=stop+1;i<Xd->r;i++)
<       { Xd->M[i-stop+start]=Xd->M[i];}
---
> 			for (i = stop + 1; i < Xd->r; i++) {
> 				Xd->M[i - stop + start] = Xd->M[i];
> 			}
297,298c369,371
<       for (i=1;i<=stop-start;i++)
<       { Xd->M[Xd->r-1+i]=dum[i];}
---
> 			for (i = 1; i <= stop - start; i++) {
> 				Xd->M[Xd->r - 1 + i] = dum[i];
> 			}
305,306c378,379
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots)
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu, int n_knots)
355c428,429
< { matrix X1,E,U,v,TU,T,Z,p;
---
> {
> 	matrix X1, E, U, v, TU, T, Z, p;
358c432,433
<   double w,*xc,*XMi,*Ea,*Ua,tol=DOUBLE_EPS,*b,*a,*uz,alpha=1.0,beta=0.0,*p0,*p1;
---
> 	double w, *xc, *XMi, *Ea, *Ua, tol = DOUBLE_EPS, *b, *a, *uz, alpha = 1.0,
> 			beta = 0.0, *p0, *p1;
362,363c437,443
<   { *Xu=initmat(n,d+1);
<     for (i=0;i<n;i++) { for (j=0;j<d;j++) Xu->M[i][j]=x[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n, d + 1);
> 		for (i = 0; i < n; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = x[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
365,366c445,451
<   { *Xu=initmat(n_knots,d+1);
<     for (i=0;i<n_knots;i++) { for (j=0;j<d;j++) Xu->M[i][j]=knt[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n_knots, d + 1);
> 		for (i = 0; i < n_knots; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = knt[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
375,376c459,466
<   error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
<   if (2*m<=d) { m=0;while (2*m<d+2) m++;} 
---
> 		error(
> 				_(
> 						"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
> 	if (2 * m <= d) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
382,383c472,477
<   {  k=M+1;
<      if (Xu->r<k) error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
---
> 	{
> 		k = M + 1;
> 		if (Xu->r < k)
> 			error(
> 					_(
> 							"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
385c479,480
<   if (Xu->r==k) pure_knot=1; /* basis dimension is number of knots - don't need eigen step */
---
> 	if (Xu->r == k)
> 		pure_knot = 1; /* basis dimension is number of knots - don't need eigen step */
388c483,484
<   { *UZ=initmat(T.r+M-1+constant,T.r);
---
> 	{
> 		*UZ = initmat(T.r + M - 1 + constant, T.r);
391c487,489
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
393c491,493
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
396,398c496,497
<   } else
<   { v=initmat(k,1);    /* eigen-value matrix for E */
< 
---
> 	} else {
> 		v = initmat(k, 1); /* eigen-value matrix for E */
404c503,504
<       minus = -1;kk=k; 
---
> 		minus = -1;
> 		kk = k;
408,409c508,510
<       U = Rmatrix(Ua,E.r,k);FREE(Ea);FREE(Ua);
<     
---
> 		U = Rmatrix(Ua, E.r, k);
> 		FREE(Ea);
> 		FREE(Ua);
419c520,521
<     *UZ=initmat(U.r+M-1+constant,U.c);UZ->r=U.r;
---
> 		*UZ = initmat(U.r + M - 1 + constant, U.c);
> 		UZ->r = U.r;
421c523,524
<     HQmult(*UZ,Z,0,0);UZ->c -= M;      /* Now UZ multiplied by truncated delta gives full delta */
---
> 		HQmult(*UZ, Z, 0, 0);
> 		UZ->c -= M; /* Now UZ multiplied by truncated delta gives full delta */
426,427c529,533
<   for (i=0;i<E.r;i++) for (j=k-M;j<UZ->c;j++) UZ->M[i][j]=0.0;
<   for (i=0;i<M-1+constant;i++) UZ->M[UZ->r-i-1][UZ->c-i-1]=1.0;
---
> 	for (i = 0; i < E.r; i++)
> 		for (j = k - M; j < UZ->c; j++)
> 			UZ->M[i][j] = 0.0;
> 	for (i = 0; i < M - 1 + constant; i++)
> 		UZ->M[UZ->r - i - 1][UZ->c - i - 1] = 1.0;
431c537,538
<   { X1=initmat(U.r,k);
---
> 	{
> 		X1 = initmat(U.r, k);
433c540,542
<     for (i=0;i<X1.r;i++) for (j=0;j<X1.c;j++) X1.M[i][j]*=v.V[j];
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = 0; j < X1.c; j++)
> 				X1.M[i][j] *= v.V[j];
435c544,546
<     for (i=0;i<X1.r;i++) for (j=X1.c-M;j<X1.c;j++) X1.M[i][j]=0.0;
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = X1.c - M; j < X1.c; j++)
> 				X1.M[i][j] = 0.0;
438,440c549,557
<     for (i=0;i<X1.r;i++) for (j=0;j<T.c;j++) X1.M[i][X1.c-M+j]=T.M[i][j];
<     else 
<     { for (i=0;i<X1.r;i++) for (j=1;j<T.c;j++) X1.M[i][X1.c-M+j-1]=T.M[i][j];X1.c--;}
---
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 0; j < T.c; j++)
> 					X1.M[i][X1.c - M + j] = T.M[i][j];
> 		else {
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 1; j < T.c; j++)
> 					X1.M[i][X1.c - M + j - 1] = T.M[i][j];
> 			X1.c--;
> 		}
444,446c561,564
<     for (i=0;i<n;i++)
<     { l=yxindex[i];
<       for (j=0;j<X1.c;j++) X->M[i][j]=X1.M[l][j];
---
> 		for (i = 0; i < n; i++) {
> 			l = yxindex[i];
> 			for (j = 0; j < X1.c; j++)
> 				X->M[i][j] = X1.M[l][j];
450c568,569
<   { p.r=0; /* don't want a value from tps_g() */
---
> 	{
> 		p.r = 0; /* don't want a value from tps_g() */
461c580,581
<       for (j=0;j<d;j++) xc[j]=x[j][i];
---
> 			for (j = 0; j < d; j++)
> 				xc[j] = x[j][i];
466c586,587
<       F77_CALL(dgemv)(&trans,&kk,&k,&alpha,uz,&kk, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &kk, &k, &alpha, uz, &kk, b, &one, &beta, a,
> 					&one); /* BLAS call for (UZ)'b */
468c589,590
<       for (p0=a,p1=a+k;p0<p1;p0++,XMi++) *XMi = *p0;
---
> 			for (p0 = a, p1 = a + k; p0 < p1; p0++, XMi++)
> 				*XMi = *p0;
477c599,602
<     FREE(xc);FREE(b);FREE(a);FREE(uz);
---
> 		FREE(xc);
> 		FREE(b);
> 		FREE(a);
> 		FREE(uz);
481,485c606,619
<   if (pure_knot) mcopy(&E,S);
<   else for (i=0;i<v.r;i++) S->M[i][i]=v.V[i];
<   HQmult(*S,Z,0,0);HQmult(*S,Z,1,1);
<   for (i=0;i<S->r;i++) for (j=S->r-M;j<S->r;j++) S->M[i][j]=S->M[j][i]=0.0;
<   if (!constant) {S->r--;S->c--;}
---
> 	if (pure_knot)
> 		mcopy(&E, S);
> 	else
> 		for (i = 0; i < v.r; i++)
> 			S->M[i][i] = v.V[i];
> 	HQmult(*S, Z, 0, 0);
> 	HQmult(*S, Z, 1, 1);
> 	for (i = 0; i < S->r; i++)
> 		for (j = S->r - M; j < S->r; j++)
> 			S->M[i][j] = S->M[j][i] = 0.0;
> 	if (!constant) {
> 		S->r--;
> 		S->c--;
> 	}
491,496c625,646
<   for (i=0;i<X->c;i++)
<   { w=0; for (j=0;j<X->r;j++) w+=X->M[j][i]*X->M[j][i]; w=sqrt(w/X->r);
<     for (j=0;j<X->r;j++) X->M[j][i]/=w;
<     for (j=0;j<UZ->r;j++) UZ->M[j][i]/=w;
<     for (j=0;j<S->r;j++) S->M[i][j]/=w;
<     for (j=0;j<S->r;j++) S->M[j][i]/=w;
---
> 	for (i = 0; i < X->c; i++) {
> 		w = 0;
> 		for (j = 0; j < X->r; j++)
> 			w += X->M[j][i] * X->M[j][i];
> 		w = sqrt(w / X->r);
> 		for (j = 0; j < X->r; j++)
> 			X->M[j][i] /= w;
> 		for (j = 0; j < UZ->r; j++)
> 			UZ->M[j][i] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[i][j] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[j][i] /= w;
> 	}
> 	FREE(yxindex);
> 	freemat(Z);
> 	freemat(TU);
> 	freemat(E);
> 	freemat(T);
> 	if (!pure_knot) {
> 		freemat(U);
> 		freemat(v);
498,499d647
<   FREE(yxindex);freemat(Z);freemat(TU);freemat(E);freemat(T);
<   if (!pure_knot) {freemat(U);freemat(v);}
502,504c650,652
< 
< void construct_tprs(double *x,int *d,int *n,double *knt,int *nk,int *m,int *k,double *X,double *S,
<                     double *UZ,double *Xu,int *nXu,double *C)
---
> void construct_tprs(double *x, int *d, int *n, double *knt, int *nk, int *m,
> 		int *k, double *X, double *S, double *UZ, double *Xu, int *nXu,
> 		double *C)
520c668,669
< { double **xx,**kk=NULL,*dum,**XM;
---
> {
> 	double **xx, **kk = NULL, *dum, **XM;
524,527c673,678
<   for (i=0;i<*d;i++) xx[i]=x + i * *n;
<   if (*nk)
<   { kk=(double **)CALLOC((size_t)(*d),sizeof(double*));
<     for (i=0;i<*d;i++) kk[i]=knt + i * *nk;
---
> 	for (i = 0; i < *d; i++)
> 		xx[i] = x + i * *n;
> 	if (*nk) {
> 		kk = (double **) CALLOC((size_t) (*d), sizeof(double*));
> 		for (i = 0; i < *d; i++)
> 			kk[i] = knt + i * *nk;
536,539c687,693
<   dum=C;XM=Xm.M;Xr=Xm.r;
<   for (i=0;i< *k;i++)
<   { *dum = 0.0;
<     for (j=0;j<Xr;j++) *dum += XM[j][i];
---
> 	dum = C;
> 	XM = Xm.M;
> 	Xr = Xm.r;
> 	for (i = 0; i < *k; i++) {
> 		*dum = 0.0;
> 		for (j = 0; j < Xr; j++)
> 			*dum += XM[j][i];
542,543c696,702
<   freemat(Xm);freemat(Sm);freemat(UZm);freemat(Xum);
<   FREE(xx);if(*nk) FREE(kk);
---
> 	freemat(Xm);
> 	freemat(Sm);
> 	freemat(UZm);
> 	freemat(Xum);
> 	FREE(xx);
> 	if (*nk)
> 		FREE(kk);
546,547c705,706
< void predict_tprs(double *x, int *d,int *n,int *m,int *k,int *M,double *Xu,int *nXu,
<                   double *UZ,double *by,int *by_exists,double *X)
---
> void predict_tprs(double *x, int *d, int *n, int *m, int *k, int *M, double *Xu,
> 		int *nXu, double *UZ, double *by, int *by_exists, double *X)
558,559c717,719
< { double *b,by_mult,*xx,*a,*xp,*xxp,*xxp1,*xp1,*Xp,alpha=1.0,beta=0.0,*Xup,*Xup1,r,z,*pb,
<          eta0;
---
> {
> 	double *b, by_mult, *xx, *a, *xp, *xxp, *xxp1, *xp1, *Xp, alpha = 1.0,
> 			beta = 0.0, *Xup, *Xup1, r, z, *pb, eta0;
563c723,727
<   if (2 * *m <= *d && *d > 0) { *m = 0;while ( 2 * *m < *d+2) (*m)++;} 
---
> 	if (2 * *m <= *d && *d > 0) {
> 		*m = 0;
> 		while (2 * *m < *d + 2)
> 			(*m)++;
> 	}
576,577c740,744
<   for (Xp=X,xp=x,i=0;i< *n;i++,xp++,Xp++) 
<   { if (*by_exists) by_mult=by[i]; else by_mult=1.0;
---
> 	for (Xp = X, xp = x, i = 0; i < *n; i++, xp++, Xp++) {
> 		if (*by_exists)
> 			by_mult = by[i];
> 		else
> 			by_mult = 1.0;
580c747,748
<       for (xxp=Xp,j=0;j < *k;j++,xxp+= *n) *xxp = 0.0; 
---
> 			for (xxp = Xp, j = 0; j < *k; j++, xxp += *n)
> 				*xxp = 0.0;
582c750,752
<       for (xxp=xx,xxp1=xx + *d,xp1=xp;xxp < xxp1;xxp++,xp1 += *n) *xxp = *xp1; /*xx[j]=x[j * *n + i];*/
---
> 			for (xxp = xx, xxp1 = xx + *d, xp1 = xp; xxp < xxp1; xxp++, xp1 +=
> 					*n)
> 				*xxp = *xp1; /*xx[j]=x[j * *n + i];*/
586c756,760
<         for (xxp=xx,xxp1=xx + *d,xp1=Xup;xxp<xxp1;xxp++,xp1+= *nXu) { z = *xp1 - *xxp;r += z*z;}
---
> 				for (xxp = xx, xxp1 = xx + *d, xp1 = Xup; xxp < xxp1;
> 						xxp++, xp1 += *nXu) {
> 					z = *xp1 - *xxp;
> 					r += z * z;
> 				}
593c767,769
<         for (j=0;j<*d;j++) for (kk=0;kk<pin[l + *M * j];kk++)  r *= xx[j];
---
> 				for (j = 0; j < *d; j++)
> 					for (kk = 0; kk < pin[l + *M * j]; kk++)
> 						r *= xx[j];
599c775,776
<       F77_CALL(dgemv)(&trans,&nobsM,k,&alpha,UZ,&nobsM, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &nobsM, k, &alpha, UZ, &nobsM, b, &one,
> 					&beta, a, &one); /* BLAS call for (UZ)'b */
601c778,780
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp * by_mult; 
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp * by_mult;
603c782,784
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp;
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp;
617,618c798,801
<   FREE(b);FREE(a);
<   FREE(xx);FREE(pin);
---
> 	FREE(b);
> 	FREE(a);
> 	FREE(xx);
> 	FREE(pin);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.h Recommended/mgcv/src/tprs.h
10,12c10,14
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant);
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant);
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
18,21c20,22
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
< 
< 
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
